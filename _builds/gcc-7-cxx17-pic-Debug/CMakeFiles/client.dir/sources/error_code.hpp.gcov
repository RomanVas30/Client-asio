        -:    0:Source:/root/.hunter/_Base/70287b1/fc9dcb2/dffbc08/Install/include/boost/system/error_code.hpp
        -:    0:Graph:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/client.dir/sources/client.cpp.gcno
        -:    0:Data:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/client.dir/sources/client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://  boost/system/error_code.hpp  -------------------------------------------------------//
        -:    2:
        -:    3://  Copyright Beman Dawes 2006, 2007
        -:    4://  Copyright Christoper Kohlhoff 2007
        -:    5://  Copyright Peter Dimov 2017, 2018
        -:    6:
        -:    7://  Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8://  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9:
        -:   10://  See library home page at http://www.boost.org/libs/system
        -:   11:
        -:   12:#ifndef BOOST_SYSTEM_ERROR_CODE_HPP
        -:   13:#define BOOST_SYSTEM_ERROR_CODE_HPP
        -:   14:
        -:   15:#include <boost/system/config.hpp>
        -:   16:#include <boost/cstdint.hpp>
        -:   17:#include <boost/assert.hpp>
        -:   18:#include <boost/noncopyable.hpp>
        -:   19:#include <boost/utility/enable_if.hpp>
        -:   20:#include <ostream>
        -:   21:#include <string>
        -:   22:#include <stdexcept>
        -:   23:#include <functional>
        -:   24:
        -:   25:// TODO: undef these macros if not already defined
        -:   26:#include <boost/cerrno.hpp>
        -:   27:
        -:   28:#if !defined(BOOST_POSIX_API) && !defined(BOOST_WINDOWS_API)
        -:   29:#  error BOOST_POSIX_API or BOOST_WINDOWS_API must be defined
        -:   30:#endif
        -:   31:
        -:   32:#ifndef BOOST_NO_CXX11_HDR_SYSTEM_ERROR
        -:   33:#include <system_error>
        -:   34:#endif
        -:   35:
        -:   36:#include <boost/config/abi_prefix.hpp> // must be the last #include
        -:   37:
        -:   38:#ifndef BOOST_SYSTEM_NOEXCEPT
        -:   39:#define BOOST_SYSTEM_NOEXCEPT BOOST_NOEXCEPT
        -:   40:#endif
        -:   41:
        -:   42:#if !defined(BOOST_NO_CXX14_CONSTEXPR)
        -:   43:# define BOOST_SYSTEM_HAS_CONSTEXPR
        -:   44:#endif
        -:   45:
        -:   46:#if defined(__GNUC__) && (__GNUC__ == 7 && __GNUC_MINOR__ < 4) && __cplusplus >= 201700L
        -:   47:// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83835
        -:   48:#  undef BOOST_SYSTEM_HAS_CONSTEXPR
        -:   49:#endif
        -:   50:
        -:   51:#if defined(__clang__) && defined(_MSC_VER) && defined(_CPPLIB_VER)
        -:   52:// Clang on Windows with MSVC headers, the constructor of std::error_category
        -:   53:// is not constexpr at least up to VS2017 15.7.x (_MSVC_STL_UPDATE 201803)
        -:   54:#  undef BOOST_SYSTEM_HAS_CONSTEXPR
        -:   55:#endif
        -:   56:
        -:   57:#if defined(__clang__) && defined(BOOST_LIBSTDCXX_VERSION) && BOOST_LIBSTDCXX_VERSION < 40900
        -:   58:// The constructor of std::error_category is not constexpr in libstdc++ 4.8
        -:   59:#  undef BOOST_SYSTEM_HAS_CONSTEXPR
        -:   60:#endif
        -:   61:
        -:   62:#if defined(BOOST_SYSTEM_HAS_CONSTEXPR)
        -:   63:# define BOOST_SYSTEM_CONSTEXPR constexpr
        -:   64:#else
        -:   65:# define BOOST_SYSTEM_CONSTEXPR
        -:   66:#endif
        -:   67:
        -:   68:namespace boost
        -:   69:{
        -:   70:  namespace system
        -:   71:  {
        -:   72:
        -:   73:    class error_code;         // values defined by the operating system
        -:   74:    class error_condition;    // portable generic values defined below, but ultimately
        -:   75:                              // based on the POSIX standard
        -:   76:
        -:   77:    //  "Concept" helpers  -------------------------------------------------------------//
        -:   78:
        -:   79:    template< class T >
        -:   80:    struct is_error_code_enum { static const bool value = false; };
        -:   81:
        -:   82:    template< class T >
        -:   83:    struct is_error_condition_enum { static const bool value = false; };
        -:   84:
        -:   85:    //  generic error_conditions  ------------------------------------------------------//
        -:   86:
        -:   87:    namespace errc
        -:   88:    {
        -:   89:      enum errc_t
        -:   90:      {
        -:   91:        success = 0,
        -:   92:        address_family_not_supported = EAFNOSUPPORT,
        -:   93:        address_in_use = EADDRINUSE,
        -:   94:        address_not_available = EADDRNOTAVAIL,
        -:   95:        already_connected = EISCONN,
        -:   96:        argument_list_too_long = E2BIG,
        -:   97:        argument_out_of_domain = EDOM,
        -:   98:        bad_address = EFAULT,
        -:   99:        bad_file_descriptor = EBADF,
        -:  100:        bad_message = EBADMSG,
        -:  101:        broken_pipe = EPIPE,
        -:  102:        connection_aborted = ECONNABORTED,
        -:  103:        connection_already_in_progress = EALREADY,
        -:  104:        connection_refused = ECONNREFUSED,
        -:  105:        connection_reset = ECONNRESET,
        -:  106:        cross_device_link = EXDEV,
        -:  107:        destination_address_required = EDESTADDRREQ,
        -:  108:        device_or_resource_busy = EBUSY,
        -:  109:        directory_not_empty = ENOTEMPTY,
        -:  110:        executable_format_error = ENOEXEC,
        -:  111:        file_exists = EEXIST,
        -:  112:        file_too_large = EFBIG,
        -:  113:        filename_too_long = ENAMETOOLONG,
        -:  114:        function_not_supported = ENOSYS,
        -:  115:        host_unreachable = EHOSTUNREACH,
        -:  116:        identifier_removed = EIDRM,
        -:  117:        illegal_byte_sequence = EILSEQ,
        -:  118:        inappropriate_io_control_operation = ENOTTY,
        -:  119:        interrupted = EINTR,
        -:  120:        invalid_argument = EINVAL,
        -:  121:        invalid_seek = ESPIPE,
        -:  122:        io_error = EIO,
        -:  123:        is_a_directory = EISDIR,
        -:  124:        message_size = EMSGSIZE,
        -:  125:        network_down = ENETDOWN,
        -:  126:        network_reset = ENETRESET,
        -:  127:        network_unreachable = ENETUNREACH,
        -:  128:        no_buffer_space = ENOBUFS,
        -:  129:        no_child_process = ECHILD,
        -:  130:        no_link = ENOLINK,
        -:  131:        no_lock_available = ENOLCK,
        -:  132:        no_message_available = ENODATA,
        -:  133:        no_message = ENOMSG,
        -:  134:        no_protocol_option = ENOPROTOOPT,
        -:  135:        no_space_on_device = ENOSPC,
        -:  136:        no_stream_resources = ENOSR,
        -:  137:        no_such_device_or_address = ENXIO,
        -:  138:        no_such_device = ENODEV,
        -:  139:        no_such_file_or_directory = ENOENT,
        -:  140:        no_such_process = ESRCH,
        -:  141:        not_a_directory = ENOTDIR,
        -:  142:        not_a_socket = ENOTSOCK,
        -:  143:        not_a_stream = ENOSTR,
        -:  144:        not_connected = ENOTCONN,
        -:  145:        not_enough_memory = ENOMEM,
        -:  146:        not_supported = ENOTSUP,
        -:  147:        operation_canceled = ECANCELED,
        -:  148:        operation_in_progress = EINPROGRESS,
        -:  149:        operation_not_permitted = EPERM,
        -:  150:        operation_not_supported = EOPNOTSUPP,
        -:  151:        operation_would_block = EWOULDBLOCK,
        -:  152:        owner_dead = EOWNERDEAD,
        -:  153:        permission_denied = EACCES,
        -:  154:        protocol_error = EPROTO,
        -:  155:        protocol_not_supported = EPROTONOSUPPORT,
        -:  156:        read_only_file_system = EROFS,
        -:  157:        resource_deadlock_would_occur = EDEADLK,
        -:  158:        resource_unavailable_try_again = EAGAIN,
        -:  159:        result_out_of_range = ERANGE,
        -:  160:        state_not_recoverable = ENOTRECOVERABLE,
        -:  161:        stream_timeout = ETIME,
        -:  162:        text_file_busy = ETXTBSY,
        -:  163:        timed_out = ETIMEDOUT,
        -:  164:        too_many_files_open_in_system = ENFILE,
        -:  165:        too_many_files_open = EMFILE,
        -:  166:        too_many_links = EMLINK,
        -:  167:        too_many_symbolic_link_levels = ELOOP,
        -:  168:        value_too_large = EOVERFLOW,
        -:  169:        wrong_protocol_type = EPROTOTYPE
        -:  170:      };
        -:  171:
        -:  172:    } // namespace errc
        -:  173:
        -:  174:# ifdef BOOST_SYSTEM_ENABLE_DEPRECATED
        -:  175:    namespace posix = errc;
        -:  176:    namespace posix_error = errc;
        -:  177:# endif
        -:  178:
        -:  179:    template<> struct is_error_condition_enum<errc::errc_t>
        -:  180:      { static const bool value = true; };
        -:  181:
        -:  182:
        -:  183:    //  --------------------------------------------------------------------------------//
        -:  184:
        -:  185:    //  Operating system specific interfaces  ------------------------------------------//
        -:  186:
        -:  187:
        -:  188:    //  The interface is divided into general and system-specific portions to
        -:  189:    //  meet these requirements:
        -:  190:    //
        -:  191:    //  * Code calling an operating system API can create an error_code with
        -:  192:    //    a single category (system_category), even for POSIX-like operating
        -:  193:    //    systems that return some POSIX errno values and some native errno
        -:  194:    //    values. This code should not have to pay the cost of distinguishing
        -:  195:    //    between categories, since it is not yet known if that is needed.
        -:  196:    //
        -:  197:    //  * Users wishing to write system-specific code should be given enums for
        -:  198:    //    at least the common error cases.
        -:  199:    //
        -:  200:    //  * System specific code should fail at compile time if moved to another
        -:  201:    //    operating system.
        -:  202:
        -:  203:    //  The system specific portions of the interface are located in headers
        -:  204:    //  with names reflecting the operating system. For example,
        -:  205:    //
        -:  206:    //       <boost/system/cygwin_error.hpp>
        -:  207:    //       <boost/system/linux_error.hpp>
        -:  208:    //       <boost/system/windows_error.hpp>
        -:  209:    //
        -:  210:    //  These headers are effectively empty for compiles on operating systems
        -:  211:    //  where they are not applicable.
        -:  212:
        -:  213:    //  --------------------------------------------------------------------------------//
        -:  214:
        -:  215:#ifdef BOOST_MSVC
        -:  216:#pragma warning(push)
        -:  217:// 'this' : used in base member initializer list
        -:  218:#pragma warning(disable: 4355)
        -:  219:#endif
        -:  220:
        -:  221:    //  class error_category  ------------------------------------------------//
        -:  222:
        -:  223:    class error_category : public noncopyable
        -:  224:    {
        -:  225:#ifndef BOOST_NO_CXX11_HDR_SYSTEM_ERROR
        -:  226:
        -:  227:    private:
        -:  228:
    #####:  229:      class std_category: public std::error_category
        -:  230:      {
        -:  231:      private:
        -:  232:
        -:  233:        boost::system::error_category const * pc_;
        -:  234:
        -:  235:      public:
        -:  236:
    #####:  237:        BOOST_SYSTEM_CONSTEXPR explicit std_category( boost::system::error_category const * pc ): pc_( pc )
        -:  238:        {
    #####:  239:        }
        -:  240:
    #####:  241:        virtual const char * name() const BOOST_NOEXCEPT
        -:  242:        {
    #####:  243:          return pc_->name();
        -:  244:        }
        -:  245:
    #####:  246:        virtual std::string message( int ev ) const
        -:  247:        {
    #####:  248:          return pc_->message( ev );
        -:  249:        }
        -:  250:
        -:  251:        virtual std::error_condition default_error_condition( int ev ) const
        -:  252:          BOOST_NOEXCEPT;
        -:  253:        virtual bool equivalent( int code, const std::error_condition & condition ) const
        -:  254:          BOOST_NOEXCEPT;
        -:  255:        virtual bool equivalent( const std::error_code & code, int condition ) const
        -:  256:          BOOST_NOEXCEPT;
        -:  257:      };
        -:  258:
        -:  259:      std_category std_cat_;
        -:  260:
        -:  261:    public:
        -:  262:
    #####:  263:      BOOST_SYSTEM_CONSTEXPR error_category() BOOST_SYSTEM_NOEXCEPT: std_cat_( this ) {}
        -:  264:
    #####:  265:      operator std::error_category const & () const BOOST_SYSTEM_NOEXCEPT
        -:  266:      {
        -:  267:        // do not map generic to std::generic on purpose; occasionally,
        -:  268:        // there are two std::generic categories in a program, which leads
        -:  269:        // to error codes/conditions mysteriously not being equal to themselves
    #####:  270:        return std_cat_;
        -:  271:      }
        -:  272:
        -:  273:#else
        -:  274:
        -:  275:    // to maintain ABI compatibility between 03 and 11,
        -:  276:    // define a class with the same layout
        -:  277:
        -:  278:    private:
        -:  279:
        -:  280:      class std_category
        -:  281:      {
        -:  282:      private:
        -:  283:
        -:  284:        boost::system::error_category const * pc_;
        -:  285:
        -:  286:      public:
        -:  287:
        -:  288:        BOOST_SYSTEM_CONSTEXPR explicit std_category( boost::system::error_category const * pc ): pc_( pc )
        -:  289:        {
        -:  290:        }
        -:  291:
        -:  292:        virtual ~std_category() {}
        -:  293:
        -:  294:        virtual const char * name() const BOOST_NOEXCEPT
        -:  295:        {
        -:  296:          return pc_->name();
        -:  297:        }
        -:  298:
        -:  299:        // we can't define message, because (1) it returns an std::string,
        -:  300:        // which can be different between 03 and 11, and (2) on mingw, there
        -:  301:        // are actually two `message` functions, not one, so it doesn't work
        -:  302:        // even if we do
        -:  303:
        -:  304:        // neither can we define default_error_condition or equivalent
        -:  305:
        -:  306:        // if these functions are called, it will crash, but that's still
        -:  307:        // better than the alternative of having the class layout change
        -:  308:      };
        -:  309:
        -:  310:      std_category std_cat_;
        -:  311:
        -:  312:    public:
        -:  313:
        -:  314:      BOOST_SYSTEM_CONSTEXPR error_category() BOOST_SYSTEM_NOEXCEPT: std_cat_( this ) {}
        -:  315:
        -:  316:#endif
        -:  317:
        -:  318:    public:
    #####:  319:      virtual ~error_category(){}
        -:  320:
        -:  321:      virtual const char *     name() const BOOST_SYSTEM_NOEXCEPT = 0;
        -:  322:      virtual std::string      message( int ev ) const = 0;
        -:  323:      inline virtual error_condition  default_error_condition( int ev ) const 
        -:  324:        BOOST_SYSTEM_NOEXCEPT;
        -:  325:      inline virtual bool             equivalent( int code,
        -:  326:                                           const error_condition & condition ) const 
        -:  327:        BOOST_SYSTEM_NOEXCEPT;
        -:  328:      inline virtual bool             equivalent( const error_code & code,
        -:  329:                                           int condition ) const  BOOST_SYSTEM_NOEXCEPT;
        -:  330:    };
        -:  331:
    #####:  332:    BOOST_SYSTEM_CONSTEXPR inline bool operator==( const error_category & lhs,
        -:  333:        const error_category & rhs ) BOOST_SYSTEM_NOEXCEPT
    #####:  334:        { return &lhs == &rhs; }
        -:  335:
        -:  336:    BOOST_SYSTEM_CONSTEXPR inline bool operator!=( const error_category & lhs,
        -:  337:        const error_category & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  338:        { return &lhs != &rhs; }
        -:  339:
        -:  340:    inline bool operator<( const error_category & lhs,
        -:  341:        const error_category & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  342:        { return std::less<const error_category*>()( &lhs, &rhs ); }
        -:  343:
        -:  344:#ifdef BOOST_MSVC
        -:  345:#pragma warning(pop)
        -:  346:#endif
        -:  347:
        -:  348:    //  predefined error categories  ---------------------------------------------------//
        -:  349:
        -:  350:namespace detail
        -:  351:{
        -:  352:
        -:  353:#ifdef BOOST_ERROR_CODE_HEADER_ONLY
        -:  354:# define BOOST_SYSTEM_DECL_
        -:  355:#else
        -:  356:# define BOOST_SYSTEM_DECL_ BOOST_SYSTEM_DECL
        -:  357:#endif
        -:  358:
        -:  359:class generic_error_category: public error_category
        -:  360:{
        -:  361:public:
        -:  362:
        -:  363:    // clang++ 3.8 and below: initialization of const object
        -:  364:    // requires a user-provided default constructor
        -:  365:    BOOST_SYSTEM_CONSTEXPR generic_error_category() BOOST_SYSTEM_NOEXCEPT
        -:  366:    {
        -:  367:    }
        -:  368:
        -:  369:    const char * name() const BOOST_SYSTEM_NOEXCEPT
        -:  370:    {
        -:  371:        return "generic";
        -:  372:    }
        -:  373:
        -:  374:    BOOST_SYSTEM_DECL_ std::string message( int ev ) const;
        -:  375:};
        -:  376:
        -:  377:class system_error_category: public error_category
        -:  378:{
        -:  379:public:
        -:  380:
        -:  381:    BOOST_SYSTEM_CONSTEXPR system_error_category() BOOST_SYSTEM_NOEXCEPT
        -:  382:    {
        -:  383:    }
        -:  384:
        -:  385:    const char * name() const BOOST_SYSTEM_NOEXCEPT
        -:  386:    {
        -:  387:        return "system";
        -:  388:    }
        -:  389:
        -:  390:    BOOST_SYSTEM_DECL_ std::string message( int ev ) const;
        -:  391:    BOOST_SYSTEM_DECL_ error_condition default_error_condition( int ev ) const BOOST_SYSTEM_NOEXCEPT;
        -:  392:};
        -:  393:
        -:  394:#undef BOOST_SYSTEM_DECL_
        -:  395:
        -:  396:} // namespace detail
        -:  397:
        -:  398:#define BOOST_SYSTEM_REQUIRE_CONST_INIT
        -:  399:
        -:  400:#if defined(__has_cpp_attribute)
        -:  401:#if __has_cpp_attribute(clang::require_constant_initialization)
        -:  402:# undef BOOST_SYSTEM_REQUIRE_CONST_INIT
        -:  403:# define BOOST_SYSTEM_REQUIRE_CONST_INIT [[clang::require_constant_initialization]]
        -:  404:#endif
        -:  405:#endif
        -:  406:
        -:  407:#if defined(BOOST_ERROR_CODE_HEADER_ONLY)
        -:  408:
        -:  409:# if defined(BOOST_SYSTEM_HAS_CONSTEXPR)
        -:  410:
        -:  411:namespace detail
        -:  412:{
        -:  413:
        -:  414:template<class T> struct cat_holder
        -:  415:{
        -:  416:    static system_error_category system_category_instance;
        -:  417:    static generic_error_category generic_category_instance;
        -:  418:};
        -:  419:
        -:  420:template<class T> BOOST_SYSTEM_REQUIRE_CONST_INIT system_error_category cat_holder<T>::system_category_instance;
        -:  421:template<class T> BOOST_SYSTEM_REQUIRE_CONST_INIT generic_error_category cat_holder<T>::generic_category_instance;
        -:  422:
        -:  423:} // namespace detail
        -:  424:
        -:  425:constexpr const error_category & system_category() BOOST_SYSTEM_NOEXCEPT
        -:  426:{
        -:  427:    return detail::cat_holder<void>::system_category_instance;
        -:  428:}
        -:  429:
        -:  430:constexpr const error_category & generic_category() BOOST_SYSTEM_NOEXCEPT
        -:  431:{
        -:  432:    return detail::cat_holder<void>::generic_category_instance;
        -:  433:}
        -:  434:
        -:  435:# else
        -:  436:
        -:  437:inline const error_category & system_category() BOOST_SYSTEM_NOEXCEPT
        -:  438:{
        -:  439:    static const detail::system_error_category system_category_instance;
        -:  440:    return system_category_instance;
        -:  441:}
        -:  442:
        -:  443:inline const error_category & generic_category() BOOST_SYSTEM_NOEXCEPT
        -:  444:{
        -:  445:    static const detail::generic_error_category generic_category_instance;
        -:  446:    return generic_category_instance;
        -:  447:}
        -:  448:
        -:  449:# endif
        -:  450:
        -:  451:#elif defined(BOOST_SYSTEM_HAS_CONSTEXPR)
        -:  452:
        -:  453:namespace detail
        -:  454:{
        -:  455:
        -:  456:#if defined(BOOST_SYSTEM_SOURCE)
        -:  457:
        -:  458:// clang++ requires a strictly matching declaration
        -:  459:BOOST_SYSTEM_DECL extern system_error_category system_category_instance;
        -:  460:BOOST_SYSTEM_DECL extern generic_error_category generic_category_instance;
        -:  461:
        -:  462:#else
        -:  463:
        -:  464:extern system_error_category system_category_instance;
        -:  465:extern generic_error_category generic_category_instance;
        -:  466:
        -:  467:#endif
        -:  468:
        -:  469:} // namespace detail
        -:  470:
        -:  471:constexpr const error_category & system_category() BOOST_SYSTEM_NOEXCEPT
        -:  472:{
        -:  473:    return detail::system_category_instance;
        -:  474:}
        -:  475:
        -:  476:constexpr const error_category & generic_category() BOOST_SYSTEM_NOEXCEPT
        -:  477:{
        -:  478:    return detail::generic_category_instance;
        -:  479:}
        -:  480:
        -:  481:#else
        -:  482:
        -:  483:namespace detail
        -:  484:{
        -:  485:
        -:  486:BOOST_SYSTEM_DECL const error_category & system_category_ncx() BOOST_SYSTEM_NOEXCEPT;
        -:  487:BOOST_SYSTEM_DECL const error_category & generic_category_ncx() BOOST_SYSTEM_NOEXCEPT;
        -:  488:
        -:  489:} // namespace detail
        -:  490:
    #####:  491:inline const error_category & system_category() BOOST_SYSTEM_NOEXCEPT
        -:  492:{
    #####:  493:    return detail::system_category_ncx();
        -:  494:}
        -:  495:
    #####:  496:inline const error_category & generic_category() BOOST_SYSTEM_NOEXCEPT
        -:  497:{
    #####:  498:    return detail::generic_category_ncx();
        -:  499:}
        -:  500:
        -:  501:#endif
        -:  502:
        -:  503:    //  deprecated synonyms ------------------------------------------------------------//
        -:  504:
        -:  505:#ifdef BOOST_SYSTEM_ENABLE_DEPRECATED
        -:  506:    inline const error_category &  get_system_category() { return system_category(); }
        -:  507:    inline const error_category &  get_generic_category() { return generic_category(); }
        -:  508:    inline const error_category &  get_posix_category() { return generic_category(); }
        -:  509:    static const error_category &  posix_category BOOST_ATTRIBUTE_UNUSED
        -:  510:      = generic_category();
        -:  511:    static const error_category &  errno_ecat     BOOST_ATTRIBUTE_UNUSED
        -:  512:      = generic_category();
        -:  513:    static const error_category &  native_ecat    BOOST_ATTRIBUTE_UNUSED
        -:  514:      = system_category();
        -:  515:#endif
        -:  516:
        -:  517:    //  class error_condition  ---------------------------------------------------------//
        -:  518:
        -:  519:    //  error_conditions are portable, error_codes are system or library specific
        -:  520:
        -:  521:    class error_condition
        -:  522:    {
        -:  523:    public:
        -:  524:
        -:  525:      // constructors:
        -:  526:      BOOST_SYSTEM_CONSTEXPR error_condition() BOOST_SYSTEM_NOEXCEPT : m_val(0), m_cat(&generic_category()) {}
    #####:  527:      BOOST_SYSTEM_CONSTEXPR error_condition( int val, const error_category & cat ) BOOST_SYSTEM_NOEXCEPT
    #####:  528:        : m_val(val), m_cat(&cat) {}
        -:  529:
        -:  530:      template <class ErrorConditionEnum>
        -:  531:        error_condition(ErrorConditionEnum e,
        -:  532:          typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum> >::type*
        -:  533:            = 0) BOOST_SYSTEM_NOEXCEPT
        -:  534:      {
        -:  535:        *this = make_error_condition(e);
        -:  536:      }
        -:  537:
        -:  538:      // modifiers:
        -:  539:
        -:  540:      BOOST_SYSTEM_CONSTEXPR void assign( int val, const error_category & cat ) BOOST_SYSTEM_NOEXCEPT
        -:  541:      {
        -:  542:        m_val = val;
        -:  543:        m_cat = &cat;
        -:  544:      }
        -:  545:
        -:  546:      template<typename ErrorConditionEnum>
        -:  547:        typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum>,
        -:  548:          error_condition>::type &
        -:  549:          operator=( ErrorConditionEnum val ) BOOST_SYSTEM_NOEXCEPT
        -:  550:      {
        -:  551:        *this = make_error_condition(val);
        -:  552:        return *this;
        -:  553:      }
        -:  554:
        -:  555:      BOOST_SYSTEM_CONSTEXPR void clear() BOOST_SYSTEM_NOEXCEPT
        -:  556:      {
        -:  557:        m_val = 0;
        -:  558:        m_cat = &generic_category();
        -:  559:      }
        -:  560:
        -:  561:      // observers:
    #####:  562:      BOOST_SYSTEM_CONSTEXPR int                     value() const BOOST_SYSTEM_NOEXCEPT    { return m_val; }
    #####:  563:      BOOST_SYSTEM_CONSTEXPR const error_category &  category() const BOOST_SYSTEM_NOEXCEPT { return *m_cat; }
        -:  564:      std::string             message() const  { return m_cat->message(value()); }
        -:  565:
        -:  566:#if !defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS)
        -:  567:
        -:  568:      BOOST_SYSTEM_CONSTEXPR explicit operator bool() const BOOST_SYSTEM_NOEXCEPT  // true if error
        -:  569:      {
        -:  570:        return m_val != 0;
        -:  571:      }
        -:  572:
        -:  573:#else
        -:  574:
        -:  575:      typedef void (*unspecified_bool_type)();
        -:  576:      static void unspecified_bool_true() {}
        -:  577:
        -:  578:      BOOST_SYSTEM_CONSTEXPR operator unspecified_bool_type() const BOOST_SYSTEM_NOEXCEPT  // true if error
        -:  579:      {
        -:  580:        return m_val == 0 ? 0 : unspecified_bool_true;
        -:  581:      }
        -:  582:
        -:  583:      BOOST_SYSTEM_CONSTEXPR bool operator!() const BOOST_SYSTEM_NOEXCEPT  // true if no error
        -:  584:      {
        -:  585:        return m_val == 0;
        -:  586:      }
        -:  587:
        -:  588:#endif
        -:  589:
        -:  590:      // relationals:
        -:  591:      //  the more symmetrical non-member syntax allows enum
        -:  592:      //  conversions work for both rhs and lhs.
    #####:  593:      BOOST_SYSTEM_CONSTEXPR inline friend bool operator==( const error_condition & lhs,
        -:  594:                                     const error_condition & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  595:      {
    #####:  596:        return lhs.m_cat == rhs.m_cat && lhs.m_val == rhs.m_val;
        -:  597:      }
        -:  598:
        -:  599:      inline friend bool operator<( const error_condition & lhs,
        -:  600:                                    const error_condition & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  601:        //  the more symmetrical non-member syntax allows enum
        -:  602:        //  conversions work for both rhs and lhs.
        -:  603:      {
        -:  604:        return lhs.m_cat < rhs.m_cat
        -:  605:          || (lhs.m_cat == rhs.m_cat && lhs.m_val < rhs.m_val);
        -:  606:      }
        -:  607:
        -:  608:#ifndef BOOST_NO_CXX11_HDR_SYSTEM_ERROR
        -:  609:
    #####:  610:      operator std::error_condition () const BOOST_SYSTEM_NOEXCEPT
        -:  611:      {
    #####:  612:        return std::error_condition( value(), category() );
        -:  613:      }
        -:  614:
        -:  615:#endif
        -:  616:
        -:  617:    private:
        -:  618:      int                     m_val;
        -:  619:      const error_category *  m_cat;
        -:  620:
        -:  621:    };
        -:  622:
        -:  623:    //  class error_code  --------------------------------------------------------------//
        -:  624:
        -:  625:    //  We want error_code to be a value type that can be copied without slicing
        -:  626:    //  and without requiring heap allocation, but we also want it to have
        -:  627:    //  polymorphic behavior based on the error category. This is achieved by
        -:  628:    //  abstract base class error_category supplying the polymorphic behavior,
        -:  629:    //  and error_code containing a pointer to an object of a type derived
        -:  630:    //  from error_category.
        -:  631:    class error_code
        -:  632:    {
        -:  633:    public:
        -:  634:
        -:  635:      // constructors:
    #####:  636:      BOOST_SYSTEM_CONSTEXPR error_code() BOOST_SYSTEM_NOEXCEPT : m_val(0), m_cat(&system_category()) {}
    #####:  637:      BOOST_SYSTEM_CONSTEXPR error_code( int val, const error_category & cat ) BOOST_SYSTEM_NOEXCEPT
    #####:  638:        : m_val(val), m_cat(&cat) {}
        -:  639:
        -:  640:      template <class ErrorCodeEnum>
    #####:  641:        error_code(ErrorCodeEnum e,
        -:  642:          typename boost::enable_if<is_error_code_enum<ErrorCodeEnum> >::type* = 0)
        -:  643:          BOOST_SYSTEM_NOEXCEPT
        -:  644:      {
    #####:  645:        *this = make_error_code(e);
    #####:  646:      }
        -:  647:
        -:  648:      // modifiers:
        -:  649:      BOOST_SYSTEM_CONSTEXPR void assign( int val, const error_category & cat ) BOOST_SYSTEM_NOEXCEPT
        -:  650:      {
        -:  651:        m_val = val;
        -:  652:        m_cat = &cat;
        -:  653:      }
        -:  654:
        -:  655:      template<typename ErrorCodeEnum>
        -:  656:        typename boost::enable_if<is_error_code_enum<ErrorCodeEnum>, error_code>::type &
    #####:  657:          operator=( ErrorCodeEnum val ) BOOST_SYSTEM_NOEXCEPT
        -:  658:      {
    #####:  659:        *this = make_error_code(val);
    #####:  660:        return *this;
        -:  661:      }
        -:  662:
        -:  663:      BOOST_SYSTEM_CONSTEXPR void clear() BOOST_SYSTEM_NOEXCEPT
        -:  664:      {
        -:  665:        m_val = 0;
        -:  666:        m_cat = &system_category();
        -:  667:      }
        -:  668:
        -:  669:      // observers:
    #####:  670:      BOOST_SYSTEM_CONSTEXPR int                     value() const  BOOST_SYSTEM_NOEXCEPT   { return m_val; }
    #####:  671:      BOOST_SYSTEM_CONSTEXPR const error_category &  category() const BOOST_SYSTEM_NOEXCEPT { return *m_cat; }
        -:  672:      error_condition         default_error_condition() const BOOST_SYSTEM_NOEXCEPT
        -:  673:        { return m_cat->default_error_condition(value()); }
    #####:  674:      std::string             message() const  { return m_cat->message(value()); }
        -:  675:
        -:  676:#if !defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS)
        -:  677:
    #####:  678:      BOOST_SYSTEM_CONSTEXPR explicit operator bool() const BOOST_SYSTEM_NOEXCEPT  // true if error
        -:  679:      {
    #####:  680:        return m_val != 0;
        -:  681:      }
        -:  682:
        -:  683:#else
        -:  684:
        -:  685:      typedef void (*unspecified_bool_type)();
        -:  686:      static void unspecified_bool_true() {}
        -:  687:
        -:  688:      BOOST_SYSTEM_CONSTEXPR operator unspecified_bool_type() const  BOOST_SYSTEM_NOEXCEPT // true if error
        -:  689:      {
        -:  690:        return m_val == 0 ? 0 : unspecified_bool_true;
        -:  691:      }
        -:  692:
        -:  693:      BOOST_SYSTEM_CONSTEXPR bool operator!() const  BOOST_SYSTEM_NOEXCEPT // true if no error
        -:  694:      {
        -:  695:        return m_val == 0;
        -:  696:      }
        -:  697:
        -:  698:#endif
        -:  699:
        -:  700:      // relationals:
    #####:  701:      BOOST_SYSTEM_CONSTEXPR inline friend bool operator==( const error_code & lhs,
        -:  702:                                     const error_code & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  703:        //  the more symmetrical non-member syntax allows enum
        -:  704:        //  conversions work for both rhs and lhs.
        -:  705:      {
    #####:  706:        return lhs.m_cat == rhs.m_cat && lhs.m_val == rhs.m_val;
        -:  707:      }
        -:  708:
        -:  709:      inline friend bool operator<( const error_code & lhs,
        -:  710:                                    const error_code & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  711:        //  the more symmetrical non-member syntax allows enum
        -:  712:        //  conversions work for both rhs and lhs.
        -:  713:      {
        -:  714:        return lhs.m_cat < rhs.m_cat
        -:  715:          || (lhs.m_cat == rhs.m_cat && lhs.m_val < rhs.m_val);
        -:  716:      }
        -:  717:
        -:  718:#ifndef BOOST_NO_CXX11_HDR_SYSTEM_ERROR
        -:  719:
        -:  720:      operator std::error_code () const BOOST_SYSTEM_NOEXCEPT
        -:  721:      {
        -:  722:        return std::error_code( value(), category() );
        -:  723:      }
        -:  724:
        -:  725:#endif
        -:  726:
        -:  727:    private:
        -:  728:      int                     m_val;
        -:  729:      const error_category *  m_cat;
        -:  730:
        -:  731:    };
        -:  732:
        -:  733:    //  predefined error_code object used as "throw on error" tag
        -:  734:# ifdef BOOST_SYSTEM_ENABLE_DEPRECATED
        -:  735:    BOOST_SYSTEM_DECL extern error_code throws;
        -:  736:# endif
        -:  737:
        -:  738:    //  Moving from a "throws" object to a "throws" function without breaking
        -:  739:    //  existing code is a bit of a problem. The workaround is to place the
        -:  740:    //  "throws" function in namespace boost rather than namespace boost::system.
        -:  741:
        -:  742:  }  // namespace system
        -:  743:                                                               
        -:  744:  namespace detail
        -:  745:  {
        -:  746:    //  Misuse of the error_code object is turned into a noisy failure by
        -:  747:    //  poisoning the reference. This particular implementation doesn't
        -:  748:    //  produce warnings or errors from popular compilers, is very efficient
        -:  749:    //  (as determined by inspecting generated code), and does not suffer
        -:  750:    //  from order of initialization problems. In practice, it also seems
        -:  751:    //  cause user function error handling implementation errors to be detected
        -:  752:    //  very early in the development cycle.
        -:  753:    inline system::error_code* throws()
        -:  754:    {
        -:  755:      // See github.com/boostorg/system/pull/12 by visigoth for why the return
        -:  756:      // is poisoned with nonzero rather than (0). A test, test_throws_usage(),
        -:  757:      // has been added to error_code_test.cpp, and as visigoth mentioned it
        -:  758:      // fails on clang for release builds with a return of 0 but works fine
        -:  759:      // with (1).
        -:  760:      // Since the undefined behavior sanitizer (-fsanitize=undefined) does not
        -:  761:      // allow a reference to be formed to the unaligned address of (1), we use
        -:  762:      // (8) instead.
        -:  763:      return reinterpret_cast<system::error_code*>(8);
        -:  764:    }
        -:  765:  }
        -:  766:
        -:  767:  inline system::error_code& throws()
        -:  768:    { return *detail::throws(); }
        -:  769:
        -:  770:  namespace system
        -:  771:  {
        -:  772:    //  non-member functions  ------------------------------------------------//
        -:  773:
    #####:  774:    BOOST_SYSTEM_CONSTEXPR inline bool operator!=( const error_code & lhs,
        -:  775:                            const error_code & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  776:    {
    #####:  777:      return !(lhs == rhs);
        -:  778:    }
        -:  779:
        -:  780:    BOOST_SYSTEM_CONSTEXPR inline bool operator!=( const error_condition & lhs,
        -:  781:                            const error_condition & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  782:    {
        -:  783:      return !(lhs == rhs);
        -:  784:    }
        -:  785:
        -:  786:    inline bool operator==( const error_code & code,
        -:  787:                            const error_condition & condition ) BOOST_SYSTEM_NOEXCEPT
        -:  788:    {
        -:  789:      return code.category().equivalent( code.value(), condition )
        -:  790:        || condition.category().equivalent( code, condition.value() );
        -:  791:    }
        -:  792:
        -:  793:    inline bool operator!=( const error_code & lhs,
        -:  794:                            const error_condition & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  795:    {
        -:  796:      return !(lhs == rhs);
        -:  797:    }
        -:  798:
        -:  799:    inline bool operator==( const error_condition & condition,
        -:  800:                            const error_code & code ) BOOST_SYSTEM_NOEXCEPT
        -:  801:    {
        -:  802:      return condition.category().equivalent( code, condition.value() )
        -:  803:        || code.category().equivalent( code.value(), condition );
        -:  804:    }
        -:  805:
        -:  806:    inline bool operator!=( const error_condition & lhs,
        -:  807:                            const error_code & rhs ) BOOST_SYSTEM_NOEXCEPT
        -:  808:    {
        -:  809:      return !(lhs == rhs);
        -:  810:    }
        -:  811:
        -:  812:    // TODO: both of these may move elsewhere, but the LWG hasn't spoken yet.
        -:  813:
        -:  814:    template <class charT, class traits>
        -:  815:    inline std::basic_ostream<charT,traits>&
        -:  816:      operator<< (std::basic_ostream<charT,traits>& os, error_code ec)
        -:  817:    {
        -:  818:      os << ec.category().name() << ':' << ec.value();
        -:  819:      return os;
        -:  820:    }
        -:  821:
        -:  822:    inline std::size_t hash_value( const error_code & ec )
        -:  823:    {
        -:  824:      return static_cast<std::size_t>(ec.value())
        -:  825:        + reinterpret_cast<std::size_t>(&ec.category());
        -:  826:    }
        -:  827:
        -:  828:    //  make_* functions for errc::errc_t  ---------------------------------------------//
        -:  829:
        -:  830:    namespace errc
        -:  831:    {
        -:  832:      //  explicit conversion:
        -:  833:      inline error_code make_error_code( errc_t e ) BOOST_SYSTEM_NOEXCEPT
        -:  834:        { return error_code( e, generic_category() ); }
        -:  835:
        -:  836:      //  implicit conversion:
        -:  837:      inline error_condition make_error_condition( errc_t e ) BOOST_SYSTEM_NOEXCEPT
        -:  838:        { return error_condition( e, generic_category() ); }
        -:  839:    }
        -:  840:
        -:  841:    //  error_category default implementation  -----------------------------------------//
        -:  842:
    #####:  843:    error_condition error_category::default_error_condition( int ev ) const
        -:  844:      BOOST_SYSTEM_NOEXCEPT
        -:  845:    {
    #####:  846:      return error_condition( ev, *this );
        -:  847:    }
        -:  848:
    #####:  849:    bool error_category::equivalent( int code,
        -:  850:      const error_condition & condition ) const BOOST_SYSTEM_NOEXCEPT
        -:  851:    {
    #####:  852:      return default_error_condition( code ) == condition;
        -:  853:    }
        -:  854:
    #####:  855:    bool error_category::equivalent( const error_code & code,
        -:  856:      int condition ) const BOOST_SYSTEM_NOEXCEPT
        -:  857:    {
    #####:  858:      return *this == code.category() && code.value() == condition;
        -:  859:    }
        -:  860:
        -:  861:#ifndef BOOST_NO_CXX11_HDR_SYSTEM_ERROR
        -:  862:
    #####:  863:    inline std::error_condition error_category::std_category::default_error_condition(
        -:  864:      int ev ) const BOOST_NOEXCEPT
        -:  865:    {
    #####:  866:      return pc_->default_error_condition( ev );
        -:  867:    }
        -:  868:
    #####:  869:    inline bool error_category::std_category::equivalent( int code,
        -:  870:      const std::error_condition & condition ) const BOOST_NOEXCEPT
        -:  871:    {
    #####:  872:      if( condition.category() == *this )
        -:  873:      {
    #####:  874:        boost::system::error_condition bn( condition.value(), *pc_ );
    #####:  875:        return pc_->equivalent( code, bn );
        -:  876:      }
    #####:  877:      else if( condition.category() == std::generic_category()
    #####:  878:        || condition.category() == boost::system::generic_category() )
        -:  879:      {
        -:  880:        boost::system::error_condition bn( condition.value(),
    #####:  881:          boost::system::generic_category() );
        -:  882:
    #####:  883:        return pc_->equivalent( code, bn );
        -:  884:      }
        -:  885:#ifndef BOOST_NO_RTTI
    #####:  886:      else if( std_category const* pc2 = dynamic_cast< std_category const* >(
    #####:  887:        &condition.category() ) )
        -:  888:      {
    #####:  889:        boost::system::error_condition bn( condition.value(), *pc2->pc_ );
    #####:  890:        return pc_->equivalent( code, bn );
        -:  891:      }
        -:  892:#endif
        -:  893:      else
        -:  894:      {
    #####:  895:        return default_error_condition( code ) == condition;
        -:  896:      }
        -:  897:    }
        -:  898:
    #####:  899:    inline bool error_category::std_category::equivalent( const std::error_code & code,
        -:  900:      int condition ) const BOOST_NOEXCEPT
        -:  901:    {
    #####:  902:      if( code.category() == *this )
        -:  903:      {
    #####:  904:        boost::system::error_code bc( code.value(), *pc_ );
    #####:  905:        return pc_->equivalent( bc, condition );
        -:  906:      }
    #####:  907:      else if( code.category() == std::generic_category()
    #####:  908:        || code.category() == boost::system::generic_category() )
        -:  909:      {
        -:  910:        boost::system::error_code bc( code.value(),
    #####:  911:          boost::system::generic_category() );
        -:  912:
    #####:  913:        return pc_->equivalent( bc, condition );
        -:  914:      }
        -:  915:#ifndef BOOST_NO_RTTI
    #####:  916:      else if( std_category const* pc2 = dynamic_cast< std_category const* >(
    #####:  917:        &code.category() ) )
        -:  918:      {
    #####:  919:        boost::system::error_code bc( code.value(), *pc2->pc_ );
    #####:  920:        return pc_->equivalent( bc, condition );
        -:  921:      }
        -:  922:#endif
    #####:  923:      else if( *pc_ == boost::system::generic_category() )
        -:  924:      {
    #####:  925:        return std::generic_category().equivalent( code, condition );
        -:  926:      }
        -:  927:      else
        -:  928:      {
    #####:  929:        return false;
        -:  930:      }
        -:  931:    }
        -:  932:
        -:  933:#endif
        -:  934:
        -:  935:  } // namespace system
        -:  936:} // namespace boost
        -:  937:
        -:  938:#include <boost/config/abi_suffix.hpp> // pops abi_prefix.hpp pragmas
        -:  939:
        -:  940:# ifdef BOOST_ERROR_CODE_HEADER_ONLY
        -:  941:#   include <boost/system/detail/error_code.ipp>
        -:  942:# endif
        -:  943:
        -:  944:#endif // BOOST_SYSTEM_ERROR_CODE_HPP
