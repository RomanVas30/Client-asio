        -:    0:Source:/home/vagrant/labs/lab-08-asio-client/sources/client.cpp
        -:    0:Graph:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/client.dir/sources/client.cpp.gcno
        -:    0:Data:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/client.dir/sources/client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright 2018 Roman Vasyutin romanvas3008@gmail.com
        -:    2:
        -:    3:#include <client.hpp>
        -:    4:
        1:    5:boost::asio::io_service service;
        1:    6:boost::recursive_mutex mutex;
        -:    7:
    #####:    8:void talk_to_svr::connect(boost::asio::ip::tcp::endpoint ep) {
    #####:    9:  sock_.connect(ep);
    #####:   10:}
        -:   11:
    #####:   12:void talk_to_svr::loop() {
    #####:   13:  write("login " + username_ + "\n");
    #####:   14:  read_answer();
    #####:   15:  while (started_) {
    #####:   16:    write_request();
    #####:   17:    read_answer();
    #####:   18:    boost::this_thread::sleep(boost::posix_time::millisec
    #####:   19:                             (std::rand() % 7000));
        -:   20:  }
    #####:   21:}
        -:   22:
    #####:   23:void talk_to_svr::read_answer() {
    #####:   24:  for (unsigned i = 0; i < max_msg; ++i)
    #####:   25:    buff_[i] = ' ';
    #####:   26:  read(sock_, boost::asio::buffer(buff_),
        -:   27:       boost::bind(&talk_to_svr::read_complete, this, _1));
    #####:   28:  process_msg();
    #####:   29:}
        -:   30:
    #####:   31:void talk_to_svr::process_msg() {
    #####:   32:  std::string msg = "";
    #####:   33:  unsigned pos = 0;
    #####:   34:  for (int i = max_msg; i > -1; --i)
    #####:   35:    if (buff_[i] == '\n') {
    #####:   36:        pos = i;
    #####:   37:        break;
        -:   38:    }
    #####:   39:  for (unsigned i = 0; i < pos; ++i) {
    #####:   40:    msg += buff_[i];
        -:   41:  }
    #####:   42:  if ( msg.find("login ") == 0) on_login(msg);
    #####:   43:  else if ( msg.find("ping") == 0) on_ping(msg);
    #####:   44:  else if ( msg.find("clients ") == 0) on_clients(msg);
        -:   45:  else
        -:   46:  {
    #####:   47:    boost::recursive_mutex::scoped_lock lk(mutex);
    #####:   48:    std::cerr << "invalid msg " << msg << std::endl;
        -:   49:  }
    #####:   50:}
        -:   51:
    #####:   52:void talk_to_svr::on_login(const std::string& msg) {
    #####:   53:  boost::recursive_mutex::scoped_lock lk(mutex);
    #####:   54:  std::cout << msg << std::endl;
    #####:   55:  do_ask_clients();
    #####:   56:}
        -:   57:
    #####:   58:void talk_to_svr::on_ping(const std::string& msg) {
    #####:   59:  std::string curr_msg = msg;
    #####:   60:  std::istringstream in(msg);
    #####:   61:  std::string answer;
    #####:   62:  in >> answer >> answer;
    #####:   63:  if ( answer == "client_list_changed")
    #####:   64:    do_ask_clients();
        -:   65:  else
        -:   66:  {
    #####:   67:    boost::recursive_mutex::scoped_lock lk(mutex);
    #####:   68:    std::cout << curr_msg << std::endl;
        -:   69:  }
    #####:   70:}
        -:   71:
    #####:   72:void talk_to_svr::on_clients(const std::string& msg) {
    #####:   73:  std::string clients = msg.substr(8);
    #####:   74:  boost::recursive_mutex::scoped_lock lk(mutex);
        -:   75:  std::cout << username_ << ", new client list:"
    #####:   76:            << clients << std::endl;
    #####:   77:}
        -:   78:
    #####:   79:void talk_to_svr::do_ask_clients() {
    #####:   80:  write("ask_clients\n");
    #####:   81:  read_answer();
    #####:   82:}
        -:   83:
    #####:   84:void talk_to_svr::write(const std::string& msg) {
    #####:   85:  boost::recursive_mutex::scoped_lock lk(mutex);
    #####:   86:  sock_.write_some(boost::asio::buffer(msg));
    #####:   87:}
        -:   88:
    #####:   89:size_t talk_to_svr::read_complete(const
        -:   90:       boost::system::error_code& err) {
    #####:   91:  if (err) return 0;
    #####:   92:  bool found = false;
    #####:   93:  for (unsigned i = 0; i < max_msg; ++i)
    #####:   94:    if (buff_[i] == '\n') {
    #####:   95:      found = true;
    #####:   96:      break;
        -:   97:    }
    #####:   98:  return found ? 0 : 1;
        3:   99:}
        -:  100:
        -:  101:
        -:  102:
