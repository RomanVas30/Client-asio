        -:    0:Source:/root/.hunter/_Base/70287b1/fc9dcb2/dffbc08/Install/include/boost/thread/pthread/thread_data.hpp
        -:    0:Graph:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/client.dir/sources/client.cpp.gcno
        -:    0:Data:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/client.dir/sources/client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#ifndef BOOST_THREAD_PTHREAD_THREAD_DATA_HPP
        -:    2:#define BOOST_THREAD_PTHREAD_THREAD_DATA_HPP
        -:    3:// Distributed under the Boost Software License, Version 1.0. (See
        -:    4:// accompanying file LICENSE_1_0.txt or copy at
        -:    5:// http://www.boost.org/LICENSE_1_0.txt)
        -:    6:// (C) Copyright 2007 Anthony Williams
        -:    7:// (C) Copyright 2011-2012 Vicente J. Botet Escriba
        -:    8:
        -:    9:#include <boost/thread/detail/config.hpp>
        -:   10:#include <boost/thread/exceptions.hpp>
        -:   11:#include <boost/thread/lock_guard.hpp>
        -:   12:#include <boost/thread/lock_types.hpp>
        -:   13:#include <boost/thread/mutex.hpp>
        -:   14:#include <boost/thread/pthread/condition_variable_fwd.hpp>
        -:   15:
        -:   16:#include <boost/shared_ptr.hpp>
        -:   17:#include <boost/enable_shared_from_this.hpp>
        -:   18:#include <boost/assert.hpp>
        -:   19:#include <boost/thread/detail/platform_time.hpp>
        -:   20:#ifdef BOOST_THREAD_USES_CHRONO
        -:   21:#include <boost/chrono/system_clocks.hpp>
        -:   22:#endif
        -:   23:
        -:   24:#include <map>
        -:   25:#include <vector>
        -:   26:#include <utility>
        -:   27:
        -:   28:#if defined(__ANDROID__)
        -:   29:# ifndef PAGE_SIZE
        -:   30:#  define PAGE_SIZE 4096
        -:   31:# endif
        -:   32:#endif
        -:   33:
        -:   34:#include <pthread.h>
        -:   35:#include <unistd.h>
        -:   36:
        -:   37:#include <boost/config/abi_prefix.hpp>
        -:   38:
        -:   39:namespace boost
        -:   40:{
        -:   41:    class thread_attributes {
        -:   42:    public:
        -:   43:        thread_attributes() BOOST_NOEXCEPT {
        -:   44:            int res = pthread_attr_init(&val_);
        -:   45:            BOOST_VERIFY(!res && "pthread_attr_init failed");
        -:   46:        }
        -:   47:        ~thread_attributes() {
        -:   48:          int res = pthread_attr_destroy(&val_);
        -:   49:          BOOST_VERIFY(!res && "pthread_attr_destroy failed");
        -:   50:        }
        -:   51:        // stack
        -:   52:        void set_stack_size(std::size_t size) BOOST_NOEXCEPT {
        -:   53:          if (size==0) return;
        -:   54:#ifdef BOOST_THREAD_USES_GETPAGESIZE
        -:   55:          std::size_t page_size = getpagesize();
        -:   56:#else
        -:   57:          std::size_t page_size = ::sysconf( _SC_PAGESIZE);
        -:   58:#endif
        -:   59:#ifdef PTHREAD_STACK_MIN
        -:   60:          if (size<PTHREAD_STACK_MIN) size=PTHREAD_STACK_MIN;
        -:   61:#endif
        -:   62:          size = ((size+page_size-1)/page_size)*page_size;
        -:   63:          int res = pthread_attr_setstacksize(&val_, size);
        -:   64:          BOOST_VERIFY(!res && "pthread_attr_setstacksize failed");
        -:   65:        }
        -:   66:
        -:   67:        std::size_t get_stack_size() const BOOST_NOEXCEPT {
        -:   68:            std::size_t size;
        -:   69:            int res = pthread_attr_getstacksize(&val_, &size);
        -:   70:            BOOST_VERIFY(!res && "pthread_attr_getstacksize failed");
        -:   71:            return size;
        -:   72:        }
        -:   73:#define BOOST_THREAD_DEFINES_THREAD_ATTRIBUTES_NATIVE_HANDLE
        -:   74:
        -:   75:        typedef pthread_attr_t native_handle_type;
        -:   76:        native_handle_type* native_handle() BOOST_NOEXCEPT {
        -:   77:          return &val_;
        -:   78:        }
        -:   79:        const native_handle_type* native_handle() const BOOST_NOEXCEPT {
        -:   80:          return &val_;
        -:   81:        }
        -:   82:
        -:   83:    private:
        -:   84:        pthread_attr_t val_;
        -:   85:    };
        -:   86:
        -:   87:    class thread;
        -:   88:
        -:   89:    namespace detail
        -:   90:    {
        -:   91:        struct shared_state_base;
        -:   92:        struct tss_cleanup_function;
        -:   93:        struct thread_exit_callback_node;
        -:   94:        struct tss_data_node
        -:   95:        {
        -:   96:            boost::shared_ptr<boost::detail::tss_cleanup_function> func;
        -:   97:            void* value;
        -:   98:
        -:   99:            tss_data_node(boost::shared_ptr<boost::detail::tss_cleanup_function> func_,
        -:  100:                          void* value_):
        -:  101:                func(func_),value(value_)
        -:  102:            {}
        -:  103:        };
        -:  104:
        -:  105:        struct thread_data_base;
        -:  106:        typedef boost::shared_ptr<thread_data_base> thread_data_ptr;
        -:  107:
        -:  108:        struct BOOST_THREAD_DECL thread_data_base:
        -:  109:            enable_shared_from_this<thread_data_base>
        -:  110:        {
        -:  111:            thread_data_ptr self;
        -:  112:            pthread_t thread_handle;
        -:  113:            boost::mutex data_mutex;
        -:  114:            boost::condition_variable done_condition;
        -:  115:            bool done;
        -:  116:            bool join_started;
        -:  117:            bool joined;
        -:  118:            boost::detail::thread_exit_callback_node* thread_exit_callbacks;
        -:  119:            std::map<void const*,boost::detail::tss_data_node> tss_data;
        -:  120:
        -:  121://#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
        -:  122:            // These data must be at the end so that the access to the other fields doesn't change
        -:  123:            // when BOOST_THREAD_PROVIDES_INTERRUPTIONS is defined.
        -:  124:            // Another option is to have them always
        -:  125:            pthread_mutex_t* cond_mutex;
        -:  126:            pthread_cond_t* current_cond;
        -:  127://#endif
        -:  128:            typedef std::vector<std::pair<condition_variable*, mutex*>
        -:  129:            //, hidden_allocator<std::pair<condition_variable*, mutex*> >
        -:  130:            > notify_list_t;
        -:  131:            notify_list_t notify;
        -:  132:
        -:  133://#ifndef BOOST_NO_EXCEPTIONS
        -:  134:            typedef std::vector<shared_ptr<shared_state_base> > async_states_t;
        -:  135:            async_states_t async_states_;
        -:  136://#endif
        -:  137://#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
        -:  138:            // These data must be at the end so that the access to the other fields doesn't change
        -:  139:            // when BOOST_THREAD_PROVIDES_INTERRUPTIONS is defined.
        -:  140:            // Another option is to have them always
        -:  141:            bool interrupt_enabled;
        -:  142:            bool interrupt_requested;
        -:  143://#endif
        -:  144:            thread_data_base():
        -:  145:                thread_handle(0),
        -:  146:                done(false),join_started(false),joined(false),
        -:  147:                thread_exit_callbacks(0),
        -:  148://#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
        -:  149:                cond_mutex(0),
        -:  150:                current_cond(0),
        -:  151://#endif
        -:  152:                notify()
        -:  153://#ifndef BOOST_NO_EXCEPTIONS
        -:  154:                , async_states_()
        -:  155://#endif
        -:  156://#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
        -:  157:                , interrupt_enabled(true)
        -:  158:                , interrupt_requested(false)
        -:  159://#endif
        -:  160:            {}
        -:  161:            virtual ~thread_data_base();
        -:  162:
        -:  163:            typedef pthread_t native_handle_type;
        -:  164:
        -:  165:            virtual void run()=0;
        -:  166:            virtual void notify_all_at_thread_exit(condition_variable* cv, mutex* m)
        -:  167:            {
        -:  168:              notify.push_back(std::pair<condition_variable*, mutex*>(cv, m));
        -:  169:            }
        -:  170:
        -:  171://#ifndef BOOST_NO_EXCEPTIONS
        -:  172:            void make_ready_at_thread_exit(shared_ptr<shared_state_base> as)
        -:  173:            {
        -:  174:              async_states_.push_back(as);
        -:  175:            }
        -:  176://#endif
        -:  177:        };
        -:  178:
        -:  179:        BOOST_THREAD_DECL thread_data_base* get_current_thread_data();
        -:  180:
        -:  181:#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
        -:  182:        class interruption_checker
        -:  183:        {
        -:  184:            thread_data_base* const thread_info;
        -:  185:            pthread_mutex_t* m;
        -:  186:            bool set;
        -:  187:            bool done;
        -:  188:
    #####:  189:            void check_for_interruption()
        -:  190:            {
        -:  191:#ifndef BOOST_NO_EXCEPTIONS
    #####:  192:                if(thread_info->interrupt_requested)
        -:  193:                {
    #####:  194:                    thread_info->interrupt_requested=false;
    #####:  195:                    throw thread_interrupted(); // BOOST_NO_EXCEPTIONS protected
        -:  196:                }
        -:  197:#endif
    #####:  198:            }
        -:  199:
        -:  200:            void operator=(interruption_checker&);
        -:  201:        public:
    #####:  202:            explicit interruption_checker(pthread_mutex_t* cond_mutex,pthread_cond_t* cond):
    #####:  203:                thread_info(detail::get_current_thread_data()),m(cond_mutex),
    #####:  204:                set(thread_info && thread_info->interrupt_enabled), done(false)
        -:  205:            {
    #####:  206:                if(set)
        -:  207:                {
    #####:  208:                    lock_guard<mutex> guard(thread_info->data_mutex);
    #####:  209:                    check_for_interruption();
    #####:  210:                    thread_info->cond_mutex=cond_mutex;
    #####:  211:                    thread_info->current_cond=cond;
    #####:  212:                    BOOST_VERIFY(!pthread_mutex_lock(m));
        -:  213:                }
        -:  214:                else
        -:  215:                {
    #####:  216:                    BOOST_VERIFY(!pthread_mutex_lock(m));
        -:  217:                }
    #####:  218:            }
    #####:  219:            void unlock_if_locked()
        -:  220:            {
    #####:  221:              if ( ! done) {
    #####:  222:                if (set)
        -:  223:                {
    #####:  224:                    BOOST_VERIFY(!pthread_mutex_unlock(m));
    #####:  225:                    lock_guard<mutex> guard(thread_info->data_mutex);
    #####:  226:                    thread_info->cond_mutex=NULL;
    #####:  227:                    thread_info->current_cond=NULL;
        -:  228:                }
        -:  229:                else
        -:  230:                {
    #####:  231:                    BOOST_VERIFY(!pthread_mutex_unlock(m));
        -:  232:                }
    #####:  233:                done = true;
        -:  234:              }
    #####:  235:            }
        -:  236:
    #####:  237:            ~interruption_checker() BOOST_NOEXCEPT_IF(false)
    #####:  238:            {
    #####:  239:                unlock_if_locked();
    #####:  240:            }
        -:  241:        };
        -:  242:#endif
        -:  243:    }
        -:  244:
        -:  245:    namespace this_thread
        -:  246:    {
        -:  247:        void BOOST_THREAD_DECL yield() BOOST_NOEXCEPT;
        -:  248:
        -:  249:        namespace hidden
        -:  250:        {
    #####:  251:          inline bool always_false()
        -:  252:          {
    #####:  253:            return false;
        -:  254:          }
        -:  255:        }
        -:  256:
        -:  257:#if defined BOOST_THREAD_USES_DATETIME
        -:  258:#ifdef __DECXXX
        -:  259:        /// Workaround of DECCXX issue of incorrect template substitution
        -:  260:        template<>
        -:  261:#endif
        -:  262:        inline void sleep(system_time const& abs_time)
        -:  263:        {
        -:  264:          mutex mx;
        -:  265:          unique_lock<mutex> lock(mx);
        -:  266:          condition_variable cond;
        -:  267:          cond.timed_wait(lock, abs_time, hidden::always_false);
        -:  268:        }
        -:  269:
        -:  270:        template<typename TimeDuration>
    #####:  271:        void sleep(TimeDuration const& rel_time)
        -:  272:        {
    #####:  273:          mutex mx;
    #####:  274:          unique_lock<mutex> lock(mx);
    #####:  275:          condition_variable cond;
    #####:  276:          cond.timed_wait(lock, rel_time, hidden::always_false);
    #####:  277:        }
        -:  278:#endif
        -:  279:
        -:  280:#ifdef BOOST_THREAD_USES_CHRONO
        -:  281:        template <class Clock, class Duration>
        -:  282:        void sleep_until(const chrono::time_point<Clock, Duration>& t)
        -:  283:        {
        -:  284:          mutex mut;
        -:  285:          unique_lock<mutex> lk(mut);
        -:  286:          condition_variable cv;
        -:  287:          cv.wait_until(lk, t, hidden::always_false);
        -:  288:        }
        -:  289:
        -:  290:        template <class Rep, class Period>
        -:  291:        void sleep_for(const chrono::duration<Rep, Period>& d)
        -:  292:        {
        -:  293:          mutex mut;
        -:  294:          unique_lock<mutex> lk(mut);
        -:  295:          condition_variable cv;
        -:  296:          cv.wait_for(lk, d, hidden::always_false);
        -:  297:        }
        -:  298:#endif
        -:  299:
        -:  300:        namespace no_interruption_point
        -:  301:        {
        -:  302:#if defined BOOST_THREAD_SLEEP_FOR_IS_STEADY
        -:  303:// Use pthread_delay_np or nanosleep when available
        -:  304:// because they do not provide an interruption point.
        -:  305:
        -:  306:          namespace hidden
        -:  307:          {
        -:  308:            void BOOST_THREAD_DECL sleep_for_internal(const detail::platform_duration& ts);
        -:  309:          }
        -:  310:
        -:  311:#if defined BOOST_THREAD_USES_DATETIME
        -:  312:#ifdef __DECXXX
        -:  313:          /// Workaround of DECCXX issue of incorrect template substitution
        -:  314:          template<>
        -:  315:#endif
        -:  316:          inline void sleep(system_time const& abs_time)
        -:  317:          {
        -:  318:            const detail::real_platform_timepoint ts(abs_time);
        -:  319:            detail::platform_duration d(ts - detail::real_platform_clock::now());
        -:  320:            while (d > detail::platform_duration::zero())
        -:  321:            {
        -:  322:              d = (std::min)(d, detail::platform_milliseconds(BOOST_THREAD_POLL_INTERVAL_MILLISECONDS));
        -:  323:              hidden::sleep_for_internal(d);
        -:  324:              d = ts - detail::real_platform_clock::now();
        -:  325:            }
        -:  326:          }
        -:  327:
        -:  328:          template<typename TimeDuration>
        -:  329:          void sleep(TimeDuration const& rel_time)
        -:  330:          {
        -:  331:            hidden::sleep_for_internal(detail::platform_duration(rel_time));
        -:  332:          }
        -:  333:#endif
        -:  334:
        -:  335:#ifdef BOOST_THREAD_USES_CHRONO
        -:  336:          template <class Rep, class Period>
        -:  337:          void sleep_for(const chrono::duration<Rep, Period>& d)
        -:  338:          {
        -:  339:            hidden::sleep_for_internal(detail::platform_duration(d));
        -:  340:          }
        -:  341:
        -:  342:          template <class Duration>
        -:  343:          void sleep_until(const chrono::time_point<chrono::steady_clock, Duration>& t)
        -:  344:          {
        -:  345:            sleep_for(t - chrono::steady_clock::now());
        -:  346:          }
        -:  347:
        -:  348:          template <class Clock, class Duration>
        -:  349:          void sleep_until(const chrono::time_point<Clock, Duration>& t)
        -:  350:          {
        -:  351:            typedef typename common_type<Duration, typename Clock::duration>::type common_duration;
        -:  352:            common_duration d(t - Clock::now());
        -:  353:            while (d > common_duration::zero())
        -:  354:            {
        -:  355:              d = (std::min)(d, common_duration(chrono::milliseconds(BOOST_THREAD_POLL_INTERVAL_MILLISECONDS)));
        -:  356:              hidden::sleep_for_internal(detail::platform_duration(d));
        -:  357:              d = t - Clock::now();
        -:  358:            }
        -:  359:          }
        -:  360:#endif
        -:  361:
        -:  362:#else // BOOST_THREAD_SLEEP_FOR_IS_STEADY
        -:  363:// When pthread_delay_np and nanosleep are not available,
        -:  364:// fall back to using the interruptible sleep functions.
        -:  365:
        -:  366:#if defined BOOST_THREAD_USES_DATETIME
        -:  367:#ifdef __DECXXX
        -:  368:          /// Workaround of DECCXX issue of incorrect template substitution
        -:  369:          template<>
        -:  370:#endif
        -:  371:          inline void sleep(system_time const& abs_time)
        -:  372:          {
        -:  373:            this_thread::sleep(abs_time);
        -:  374:          }
        -:  375:
        -:  376:          template<typename TimeDuration>
        -:  377:          void sleep(TimeDuration const& rel_time)
        -:  378:          {
        -:  379:            this_thread::sleep(rel_time);
        -:  380:          }
        -:  381:#endif
        -:  382:
        -:  383:#ifdef BOOST_THREAD_USES_CHRONO
        -:  384:          template <class Clock, class Duration>
        -:  385:          void sleep_until(const chrono::time_point<Clock, Duration>& t)
        -:  386:          {
        -:  387:            this_thread::sleep_until(t);
        -:  388:          }
        -:  389:
        -:  390:          template <class Rep, class Period>
        -:  391:          void sleep_for(const chrono::duration<Rep, Period>& d)
        -:  392:          {
        -:  393:            this_thread::sleep_for(d);
        -:  394:          }
        -:  395:#endif
        -:  396:
        -:  397:#endif // BOOST_THREAD_SLEEP_FOR_IS_STEADY
        -:  398:        } // no_interruption_point
        -:  399:    } // this_thread
        -:  400:}
        -:  401:
        -:  402:#include <boost/config/abi_suffix.hpp>
        -:  403:
        -:  404:#endif
