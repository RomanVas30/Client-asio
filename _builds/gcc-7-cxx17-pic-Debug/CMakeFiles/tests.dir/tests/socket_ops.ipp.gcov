        -:    0:Source:/root/.hunter/_Base/70287b1/fc9dcb2/dffbc08/Install/include/boost/asio/detail/impl/socket_ops.ipp
        -:    0:Graph:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/tests.dir/tests/test.cpp.gcno
        -:    0:Data:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/tests.dir/tests/test.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// detail/impl/socket_ops.ipp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_SOCKET_OPS_IPP
        -:   12:#define BOOST_ASIO_DETAIL_SOCKET_OPS_IPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:
        -:   20:#include <cctype>
        -:   21:#include <cstdio>
        -:   22:#include <cstdlib>
        -:   23:#include <cstring>
        -:   24:#include <cerrno>
        -:   25:#include <new>
        -:   26:#include <boost/asio/detail/assert.hpp>
        -:   27:#include <boost/asio/detail/socket_ops.hpp>
        -:   28:#include <boost/asio/error.hpp>
        -:   29:
        -:   30:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   31:# include <codecvt>
        -:   32:# include <locale>
        -:   33:# include <string>
        -:   34:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   35:
        -:   36:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__) \
        -:   37:  || defined(__MACH__) && defined(__APPLE__)
        -:   38:# if defined(BOOST_ASIO_HAS_PTHREADS)
        -:   39:#  include <pthread.h>
        -:   40:# endif // defined(BOOST_ASIO_HAS_PTHREADS)
        -:   41:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   42:       // || defined(__MACH__) && defined(__APPLE__)
        -:   43:
        -:   44:#include <boost/asio/detail/push_options.hpp>
        -:   45:
        -:   46:namespace boost {
        -:   47:namespace asio {
        -:   48:namespace detail {
        -:   49:namespace socket_ops {
        -:   50:
        -:   51:#if !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   52:
        -:   53:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   54:struct msghdr { int msg_namelen; };
        -:   55:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   56:
        -:   57:#if defined(__hpux)
        -:   58:// HP-UX doesn't declare these functions extern "C", so they are declared again
        -:   59:// here to avoid linker errors about undefined symbols.
        -:   60:extern "C" char* if_indextoname(unsigned int, char*);
        -:   61:extern "C" unsigned int if_nametoindex(const char*);
        -:   62:#endif // defined(__hpux)
        -:   63:
        -:   64:#endif // !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   65:
    #####:   66:inline void clear_last_error()
        -:   67:{
        -:   68:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   69:  WSASetLastError(0);
        -:   70:#else
    #####:   71:  errno = 0;
        -:   72:#endif
    #####:   73:}
        -:   74:
        -:   75:#if !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   76:
        -:   77:template <typename ReturnType>
    #####:   78:inline ReturnType error_wrapper(ReturnType return_value,
        -:   79:    boost::system::error_code& ec)
        -:   80:{
        -:   81:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   82:  ec = boost::system::error_code(WSAGetLastError(),
        -:   83:      boost::asio::error::get_system_category());
        -:   84:#else
    #####:   85:  ec = boost::system::error_code(errno,
        -:   86:      boost::asio::error::get_system_category());
        -:   87:#endif
    #####:   88:  return return_value;
        -:   89:}
        -:   90:
        -:   91:template <typename SockLenType>
        -:   92:inline socket_type call_accept(SockLenType msghdr::*,
        -:   93:    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
        -:   94:{
        -:   95:  SockLenType tmp_addrlen = addrlen ? (SockLenType)*addrlen : 0;
        -:   96:  socket_type result = ::accept(s, addr, addrlen ? &tmp_addrlen : 0);
        -:   97:  if (addrlen)
        -:   98:    *addrlen = (std::size_t)tmp_addrlen;
        -:   99:  return result;
        -:  100:}
        -:  101:
        -:  102:socket_type accept(socket_type s, socket_addr_type* addr,
        -:  103:    std::size_t* addrlen, boost::system::error_code& ec)
        -:  104:{
        -:  105:  if (s == invalid_socket)
        -:  106:  {
        -:  107:    ec = boost::asio::error::bad_descriptor;
        -:  108:    return invalid_socket;
        -:  109:  }
        -:  110:
        -:  111:  clear_last_error();
        -:  112:
        -:  113:  socket_type new_s = error_wrapper(call_accept(
        -:  114:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -:  115:  if (new_s == invalid_socket)
        -:  116:    return new_s;
        -:  117:
        -:  118:#if defined(__MACH__) && defined(__APPLE__) || defined(__FreeBSD__)
        -:  119:  int optval = 1;
        -:  120:  int result = error_wrapper(::setsockopt(new_s,
        -:  121:        SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval)), ec);
        -:  122:  if (result != 0)
        -:  123:  {
        -:  124:    ::close(new_s);
        -:  125:    return invalid_socket;
        -:  126:  }
        -:  127:#endif
        -:  128:
        -:  129:  ec = boost::system::error_code();
        -:  130:  return new_s;
        -:  131:}
        -:  132:
        -:  133:socket_type sync_accept(socket_type s, state_type state,
        -:  134:    socket_addr_type* addr, std::size_t* addrlen, boost::system::error_code& ec)
        -:  135:{
        -:  136:  // Accept a socket.
        -:  137:  for (;;)
        -:  138:  {
        -:  139:    // Try to complete the operation without blocking.
        -:  140:    socket_type new_socket = socket_ops::accept(s, addr, addrlen, ec);
        -:  141:
        -:  142:    // Check if operation succeeded.
        -:  143:    if (new_socket != invalid_socket)
        -:  144:      return new_socket;
        -:  145:
        -:  146:    // Operation failed.
        -:  147:    if (ec == boost::asio::error::would_block
        -:  148:        || ec == boost::asio::error::try_again)
        -:  149:    {
        -:  150:      if (state & user_set_non_blocking)
        -:  151:        return invalid_socket;
        -:  152:      // Fall through to retry operation.
        -:  153:    }
        -:  154:    else if (ec == boost::asio::error::connection_aborted)
        -:  155:    {
        -:  156:      if (state & enable_connection_aborted)
        -:  157:        return invalid_socket;
        -:  158:      // Fall through to retry operation.
        -:  159:    }
        -:  160:#if defined(EPROTO)
        -:  161:    else if (ec.value() == EPROTO)
        -:  162:    {
        -:  163:      if (state & enable_connection_aborted)
        -:  164:        return invalid_socket;
        -:  165:      // Fall through to retry operation.
        -:  166:    }
        -:  167:#endif // defined(EPROTO)
        -:  168:    else
        -:  169:      return invalid_socket;
        -:  170:
        -:  171:    // Wait for socket to become ready.
        -:  172:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -:  173:      return invalid_socket;
        -:  174:  }
        -:  175:}
        -:  176:
        -:  177:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  178:
        -:  179:void complete_iocp_accept(socket_type s,
        -:  180:    void* output_buffer, DWORD address_length,
        -:  181:    socket_addr_type* addr, std::size_t* addrlen,
        -:  182:    socket_type new_socket, boost::system::error_code& ec)
        -:  183:{
        -:  184:  // Map non-portable errors to their portable counterparts.
        -:  185:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  186:    ec = boost::asio::error::connection_aborted;
        -:  187:
        -:  188:  if (!ec)
        -:  189:  {
        -:  190:    // Get the address of the peer.
        -:  191:    if (addr && addrlen)
        -:  192:    {
        -:  193:      LPSOCKADDR local_addr = 0;
        -:  194:      int local_addr_length = 0;
        -:  195:      LPSOCKADDR remote_addr = 0;
        -:  196:      int remote_addr_length = 0;
        -:  197:      GetAcceptExSockaddrs(output_buffer, 0, address_length,
        -:  198:          address_length, &local_addr, &local_addr_length,
        -:  199:          &remote_addr, &remote_addr_length);
        -:  200:      if (static_cast<std::size_t>(remote_addr_length) > *addrlen)
        -:  201:      {
        -:  202:        ec = boost::asio::error::invalid_argument;
        -:  203:      }
        -:  204:      else
        -:  205:      {
        -:  206:        using namespace std; // For memcpy.
        -:  207:        memcpy(addr, remote_addr, remote_addr_length);
        -:  208:        *addrlen = static_cast<std::size_t>(remote_addr_length);
        -:  209:      }
        -:  210:    }
        -:  211:
        -:  212:    // Need to set the SO_UPDATE_ACCEPT_CONTEXT option so that getsockname
        -:  213:    // and getpeername will work on the accepted socket.
        -:  214:    SOCKET update_ctx_param = s;
        -:  215:    socket_ops::state_type state = 0;
        -:  216:    socket_ops::setsockopt(new_socket, state,
        -:  217:          SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
        -:  218:          &update_ctx_param, sizeof(SOCKET), ec);
        -:  219:  }
        -:  220:}
        -:  221:
        -:  222:#else // defined(BOOST_ASIO_HAS_IOCP)
        -:  223:
        -:  224:bool non_blocking_accept(socket_type s,
        -:  225:    state_type state, socket_addr_type* addr, std::size_t* addrlen,
        -:  226:    boost::system::error_code& ec, socket_type& new_socket)
        -:  227:{
        -:  228:  for (;;)
        -:  229:  {
        -:  230:    // Accept the waiting connection.
        -:  231:    new_socket = socket_ops::accept(s, addr, addrlen, ec);
        -:  232:
        -:  233:    // Check if operation succeeded.
        -:  234:    if (new_socket != invalid_socket)
        -:  235:      return true;
        -:  236:
        -:  237:    // Retry operation if interrupted by signal.
        -:  238:    if (ec == boost::asio::error::interrupted)
        -:  239:      continue;
        -:  240:
        -:  241:    // Operation failed.
        -:  242:    if (ec == boost::asio::error::would_block
        -:  243:        || ec == boost::asio::error::try_again)
        -:  244:    {
        -:  245:      // Fall through to retry operation.
        -:  246:    }
        -:  247:    else if (ec == boost::asio::error::connection_aborted)
        -:  248:    {
        -:  249:      if (state & enable_connection_aborted)
        -:  250:        return true;
        -:  251:      // Fall through to retry operation.
        -:  252:    }
        -:  253:#if defined(EPROTO)
        -:  254:    else if (ec.value() == EPROTO)
        -:  255:    {
        -:  256:      if (state & enable_connection_aborted)
        -:  257:        return true;
        -:  258:      // Fall through to retry operation.
        -:  259:    }
        -:  260:#endif // defined(EPROTO)
        -:  261:    else
        -:  262:      return true;
        -:  263:
        -:  264:    return false;
        -:  265:  }
        -:  266:}
        -:  267:
        -:  268:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -:  269:
        -:  270:template <typename SockLenType>
        -:  271:inline int call_bind(SockLenType msghdr::*,
        -:  272:    socket_type s, const socket_addr_type* addr, std::size_t addrlen)
        -:  273:{
        -:  274:  return ::bind(s, addr, (SockLenType)addrlen);
        -:  275:}
        -:  276:
        -:  277:int bind(socket_type s, const socket_addr_type* addr,
        -:  278:    std::size_t addrlen, boost::system::error_code& ec)
        -:  279:{
        -:  280:  if (s == invalid_socket)
        -:  281:  {
        -:  282:    ec = boost::asio::error::bad_descriptor;
        -:  283:    return socket_error_retval;
        -:  284:  }
        -:  285:
        -:  286:  clear_last_error();
        -:  287:  int result = error_wrapper(call_bind(
        -:  288:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -:  289:  if (result == 0)
        -:  290:    ec = boost::system::error_code();
        -:  291:  return result;
        -:  292:}
        -:  293:
    #####:  294:int close(socket_type s, state_type& state,
        -:  295:    bool destruction, boost::system::error_code& ec)
        -:  296:{
    #####:  297:  int result = 0;
    #####:  298:  if (s != invalid_socket)
        -:  299:  {
        -:  300:    // We don't want the destructor to block, so set the socket to linger in
        -:  301:    // the background. If the user doesn't like this behaviour then they need
        -:  302:    // to explicitly close the socket.
    #####:  303:    if (destruction && (state & user_set_linger))
        -:  304:    {
        -:  305:      ::linger opt;
    #####:  306:      opt.l_onoff = 0;
    #####:  307:      opt.l_linger = 0;
    #####:  308:      boost::system::error_code ignored_ec;
    #####:  309:      socket_ops::setsockopt(s, state, SOL_SOCKET,
        -:  310:          SO_LINGER, &opt, sizeof(opt), ignored_ec);
        -:  311:    }
        -:  312:
    #####:  313:    clear_last_error();
        -:  314:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  315:    result = error_wrapper(::closesocket(s), ec);
        -:  316:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
    #####:  317:    result = error_wrapper(::close(s), ec);
        -:  318:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  319:
    #####:  320:    if (result != 0
    #####:  321:        && (ec == boost::asio::error::would_block
    #####:  322:          || ec == boost::asio::error::try_again))
        -:  323:    {
        -:  324:      // According to UNIX Network Programming Vol. 1, it is possible for
        -:  325:      // close() to fail with EWOULDBLOCK under certain circumstances. What
        -:  326:      // isn't clear is the state of the descriptor after this error. The one
        -:  327:      // current OS where this behaviour is seen, Windows, says that the socket
        -:  328:      // remains open. Therefore we'll put the descriptor back into blocking
        -:  329:      // mode and have another attempt at closing it.
        -:  330:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  331:      ioctl_arg_type arg = 0;
        -:  332:      ::ioctlsocket(s, FIONBIO, &arg);
        -:  333:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  334:# if defined(__SYMBIAN32__)
        -:  335:      int flags = ::fcntl(s, F_GETFL, 0);
        -:  336:      if (flags >= 0)
        -:  337:        ::fcntl(s, F_SETFL, flags & ~O_NONBLOCK);
        -:  338:# else // defined(__SYMBIAN32__)
    #####:  339:      ioctl_arg_type arg = 0;
    #####:  340:      ::ioctl(s, FIONBIO, &arg);
        -:  341:# endif // defined(__SYMBIAN32__)
        -:  342:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
    #####:  343:      state &= ~non_blocking;
        -:  344:
    #####:  345:      clear_last_error();
        -:  346:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  347:      result = error_wrapper(::closesocket(s), ec);
        -:  348:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
    #####:  349:      result = error_wrapper(::close(s), ec);
        -:  350:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  351:    }
        -:  352:  }
        -:  353:
    #####:  354:  if (result == 0)
    #####:  355:    ec = boost::system::error_code();
    #####:  356:  return result;
        -:  357:}
        -:  358:
        -:  359:bool set_user_non_blocking(socket_type s,
        -:  360:    state_type& state, bool value, boost::system::error_code& ec)
        -:  361:{
        -:  362:  if (s == invalid_socket)
        -:  363:  {
        -:  364:    ec = boost::asio::error::bad_descriptor;
        -:  365:    return false;
        -:  366:  }
        -:  367:
        -:  368:  clear_last_error();
        -:  369:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  370:  ioctl_arg_type arg = (value ? 1 : 0);
        -:  371:  int result = error_wrapper(::ioctlsocket(s, FIONBIO, &arg), ec);
        -:  372:#elif defined(__SYMBIAN32__)
        -:  373:  int result = error_wrapper(::fcntl(s, F_GETFL, 0), ec);
        -:  374:  if (result >= 0)
        -:  375:  {
        -:  376:    clear_last_error();
        -:  377:    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
        -:  378:    result = error_wrapper(::fcntl(s, F_SETFL, flag), ec);
        -:  379:  }
        -:  380:#else
        -:  381:  ioctl_arg_type arg = (value ? 1 : 0);
        -:  382:  int result = error_wrapper(::ioctl(s, FIONBIO, &arg), ec);
        -:  383:#endif
        -:  384:
        -:  385:  if (result >= 0)
        -:  386:  {
        -:  387:    ec = boost::system::error_code();
        -:  388:    if (value)
        -:  389:      state |= user_set_non_blocking;
        -:  390:    else
        -:  391:    {
        -:  392:      // Clearing the user-set non-blocking mode always overrides any
        -:  393:      // internally-set non-blocking flag. Any subsequent asynchronous
        -:  394:      // operations will need to re-enable non-blocking I/O.
        -:  395:      state &= ~(user_set_non_blocking | internal_non_blocking);
        -:  396:    }
        -:  397:    return true;
        -:  398:  }
        -:  399:
        -:  400:  return false;
        -:  401:}
        -:  402:
        -:  403:bool set_internal_non_blocking(socket_type s,
        -:  404:    state_type& state, bool value, boost::system::error_code& ec)
        -:  405:{
        -:  406:  if (s == invalid_socket)
        -:  407:  {
        -:  408:    ec = boost::asio::error::bad_descriptor;
        -:  409:    return false;
        -:  410:  }
        -:  411:
        -:  412:  if (!value && (state & user_set_non_blocking))
        -:  413:  {
        -:  414:    // It does not make sense to clear the internal non-blocking flag if the
        -:  415:    // user still wants non-blocking behaviour. Return an error and let the
        -:  416:    // caller figure out whether to update the user-set non-blocking flag.
        -:  417:    ec = boost::asio::error::invalid_argument;
        -:  418:    return false;
        -:  419:  }
        -:  420:
        -:  421:  clear_last_error();
        -:  422:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  423:  ioctl_arg_type arg = (value ? 1 : 0);
        -:  424:  int result = error_wrapper(::ioctlsocket(s, FIONBIO, &arg), ec);
        -:  425:#elif defined(__SYMBIAN32__)
        -:  426:  int result = error_wrapper(::fcntl(s, F_GETFL, 0), ec);
        -:  427:  if (result >= 0)
        -:  428:  {
        -:  429:    clear_last_error();
        -:  430:    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
        -:  431:    result = error_wrapper(::fcntl(s, F_SETFL, flag), ec);
        -:  432:  }
        -:  433:#else
        -:  434:  ioctl_arg_type arg = (value ? 1 : 0);
        -:  435:  int result = error_wrapper(::ioctl(s, FIONBIO, &arg), ec);
        -:  436:#endif
        -:  437:
        -:  438:  if (result >= 0)
        -:  439:  {
        -:  440:    ec = boost::system::error_code();
        -:  441:    if (value)
        -:  442:      state |= internal_non_blocking;
        -:  443:    else
        -:  444:      state &= ~internal_non_blocking;
        -:  445:    return true;
        -:  446:  }
        -:  447:
        -:  448:  return false;
        -:  449:}
        -:  450:
        -:  451:int shutdown(socket_type s, int what, boost::system::error_code& ec)
        -:  452:{
        -:  453:  if (s == invalid_socket)
        -:  454:  {
        -:  455:    ec = boost::asio::error::bad_descriptor;
        -:  456:    return socket_error_retval;
        -:  457:  }
        -:  458:
        -:  459:  clear_last_error();
        -:  460:  int result = error_wrapper(::shutdown(s, what), ec);
        -:  461:  if (result == 0)
        -:  462:    ec = boost::system::error_code();
        -:  463:  return result;
        -:  464:}
        -:  465:
        -:  466:template <typename SockLenType>
        -:  467:inline int call_connect(SockLenType msghdr::*,
        -:  468:    socket_type s, const socket_addr_type* addr, std::size_t addrlen)
        -:  469:{
        -:  470:  return ::connect(s, addr, (SockLenType)addrlen);
        -:  471:}
        -:  472:
        -:  473:int connect(socket_type s, const socket_addr_type* addr,
        -:  474:    std::size_t addrlen, boost::system::error_code& ec)
        -:  475:{
        -:  476:  if (s == invalid_socket)
        -:  477:  {
        -:  478:    ec = boost::asio::error::bad_descriptor;
        -:  479:    return socket_error_retval;
        -:  480:  }
        -:  481:
        -:  482:  clear_last_error();
        -:  483:  int result = error_wrapper(call_connect(
        -:  484:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -:  485:  if (result == 0)
        -:  486:    ec = boost::system::error_code();
        -:  487:#if defined(__linux__)
        -:  488:  else if (ec == boost::asio::error::try_again)
        -:  489:    ec = boost::asio::error::no_buffer_space;
        -:  490:#endif // defined(__linux__)
        -:  491:  return result;
        -:  492:}
        -:  493:
        -:  494:void sync_connect(socket_type s, const socket_addr_type* addr,
        -:  495:    std::size_t addrlen, boost::system::error_code& ec)
        -:  496:{
        -:  497:  // Perform the connect operation.
        -:  498:  socket_ops::connect(s, addr, addrlen, ec);
        -:  499:  if (ec != boost::asio::error::in_progress
        -:  500:      && ec != boost::asio::error::would_block)
        -:  501:  {
        -:  502:    // The connect operation finished immediately.
        -:  503:    return;
        -:  504:  }
        -:  505:
        -:  506:  // Wait for socket to become ready.
        -:  507:  if (socket_ops::poll_connect(s, -1, ec) < 0)
        -:  508:    return;
        -:  509:
        -:  510:  // Get the error code from the connect operation.
        -:  511:  int connect_error = 0;
        -:  512:  size_t connect_error_len = sizeof(connect_error);
        -:  513:  if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_ERROR,
        -:  514:        &connect_error, &connect_error_len, ec) == socket_error_retval)
        -:  515:    return;
        -:  516:
        -:  517:  // Return the result of the connect operation.
        -:  518:  ec = boost::system::error_code(connect_error,
        -:  519:      boost::asio::error::get_system_category());
        -:  520:}
        -:  521:
        -:  522:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  523:
        -:  524:void complete_iocp_connect(socket_type s, boost::system::error_code& ec)
        -:  525:{
        -:  526:  // Map non-portable errors to their portable counterparts.
        -:  527:  switch (ec.value())
        -:  528:  {
        -:  529:  case ERROR_CONNECTION_REFUSED:
        -:  530:    ec = boost::asio::error::connection_refused;
        -:  531:    break;
        -:  532:  case ERROR_NETWORK_UNREACHABLE:
        -:  533:    ec = boost::asio::error::network_unreachable;
        -:  534:    break;
        -:  535:  case ERROR_HOST_UNREACHABLE:
        -:  536:    ec = boost::asio::error::host_unreachable;
        -:  537:    break;
        -:  538:  case ERROR_SEM_TIMEOUT:
        -:  539:    ec = boost::asio::error::timed_out;
        -:  540:    break;
        -:  541:  default:
        -:  542:    break;
        -:  543:  }
        -:  544:
        -:  545:  if (!ec)
        -:  546:  {
        -:  547:    // Need to set the SO_UPDATE_CONNECT_CONTEXT option so that getsockname
        -:  548:    // and getpeername will work on the connected socket.
        -:  549:    socket_ops::state_type state = 0;
        -:  550:    const int so_update_connect_context = 0x7010;
        -:  551:    socket_ops::setsockopt(s, state, SOL_SOCKET,
        -:  552:        so_update_connect_context, 0, 0, ec);
        -:  553:  }
        -:  554:}
        -:  555:
        -:  556:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -:  557:
        -:  558:bool non_blocking_connect(socket_type s, boost::system::error_code& ec)
        -:  559:{
        -:  560:  // Check if the connect operation has finished. This is required since we may
        -:  561:  // get spurious readiness notifications from the reactor.
        -:  562:#if defined(BOOST_ASIO_WINDOWS) \
        -:  563:  || defined(__CYGWIN__) \
        -:  564:  || defined(__SYMBIAN32__)
        -:  565:  fd_set write_fds;
        -:  566:  FD_ZERO(&write_fds);
        -:  567:  FD_SET(s, &write_fds);
        -:  568:  fd_set except_fds;
        -:  569:  FD_ZERO(&except_fds);
        -:  570:  FD_SET(s, &except_fds);
        -:  571:  timeval zero_timeout;
        -:  572:  zero_timeout.tv_sec = 0;
        -:  573:  zero_timeout.tv_usec = 0;
        -:  574:  int ready = ::select(s + 1, 0, &write_fds, &except_fds, &zero_timeout);
        -:  575:#else // defined(BOOST_ASIO_WINDOWS)
        -:  576:      // || defined(__CYGWIN__)
        -:  577:      // || defined(__SYMBIAN32__)
        -:  578:  pollfd fds;
        -:  579:  fds.fd = s;
        -:  580:  fds.events = POLLOUT;
        -:  581:  fds.revents = 0;
        -:  582:  int ready = ::poll(&fds, 1, 0);
        -:  583:#endif // defined(BOOST_ASIO_WINDOWS)
        -:  584:       // || defined(__CYGWIN__)
        -:  585:       // || defined(__SYMBIAN32__)
        -:  586:  if (ready == 0)
        -:  587:  {
        -:  588:    // The asynchronous connect operation is still in progress.
        -:  589:    return false;
        -:  590:  }
        -:  591:
        -:  592:  // Get the error code from the connect operation.
        -:  593:  int connect_error = 0;
        -:  594:  size_t connect_error_len = sizeof(connect_error);
        -:  595:  if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_ERROR,
        -:  596:        &connect_error, &connect_error_len, ec) == 0)
        -:  597:  {
        -:  598:    if (connect_error)
        -:  599:    {
        -:  600:      ec = boost::system::error_code(connect_error,
        -:  601:          boost::asio::error::get_system_category());
        -:  602:    }
        -:  603:    else
        -:  604:      ec = boost::system::error_code();
        -:  605:  }
        -:  606:
        -:  607:  return true;
        -:  608:}
        -:  609:
        -:  610:int socketpair(int af, int type, int protocol,
        -:  611:    socket_type sv[2], boost::system::error_code& ec)
        -:  612:{
        -:  613:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  614:  (void)(af);
        -:  615:  (void)(type);
        -:  616:  (void)(protocol);
        -:  617:  (void)(sv);
        -:  618:  ec = boost::asio::error::operation_not_supported;
        -:  619:  return socket_error_retval;
        -:  620:#else
        -:  621:  clear_last_error();
        -:  622:  int result = error_wrapper(::socketpair(af, type, protocol, sv), ec);
        -:  623:  if (result == 0)
        -:  624:    ec = boost::system::error_code();
        -:  625:  return result;
        -:  626:#endif
        -:  627:}
        -:  628:
        -:  629:bool sockatmark(socket_type s, boost::system::error_code& ec)
        -:  630:{
        -:  631:  if (s == invalid_socket)
        -:  632:  {
        -:  633:    ec = boost::asio::error::bad_descriptor;
        -:  634:    return false;
        -:  635:  }
        -:  636:
        -:  637:#if defined(SIOCATMARK)
        -:  638:  ioctl_arg_type value = 0;
        -:  639:# if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  640:  int result = error_wrapper(::ioctlsocket(s, SIOCATMARK, &value), ec);
        -:  641:# else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  642:  int result = error_wrapper(::ioctl(s, SIOCATMARK, &value), ec);
        -:  643:# endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  644:  if (result == 0)
        -:  645:    ec = boost::system::error_code();
        -:  646:# if defined(ENOTTY)
        -:  647:  if (ec.value() == ENOTTY)
        -:  648:    ec = boost::asio::error::not_socket;
        -:  649:# endif // defined(ENOTTY)
        -:  650:#else // defined(SIOCATMARK)
        -:  651:  int value = error_wrapper(::sockatmark(s), ec);
        -:  652:  if (value != -1)
        -:  653:    ec = boost::system::error_code();
        -:  654:#endif // defined(SIOCATMARK)
        -:  655:
        -:  656:  return ec ? false : value != 0;
        -:  657:}
        -:  658:
        -:  659:size_t available(socket_type s, boost::system::error_code& ec)
        -:  660:{
        -:  661:  if (s == invalid_socket)
        -:  662:  {
        -:  663:    ec = boost::asio::error::bad_descriptor;
        -:  664:    return 0;
        -:  665:  }
        -:  666:
        -:  667:  ioctl_arg_type value = 0;
        -:  668:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  669:  int result = error_wrapper(::ioctlsocket(s, FIONREAD, &value), ec);
        -:  670:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  671:  int result = error_wrapper(::ioctl(s, FIONREAD, &value), ec);
        -:  672:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  673:  if (result == 0)
        -:  674:    ec = boost::system::error_code();
        -:  675:#if defined(ENOTTY)
        -:  676:  if (ec.value() == ENOTTY)
        -:  677:    ec = boost::asio::error::not_socket;
        -:  678:#endif // defined(ENOTTY)
        -:  679:
        -:  680:  return ec ? static_cast<size_t>(0) : static_cast<size_t>(value);
        -:  681:}
        -:  682:
        -:  683:int listen(socket_type s, int backlog, boost::system::error_code& ec)
        -:  684:{
        -:  685:  if (s == invalid_socket)
        -:  686:  {
        -:  687:    ec = boost::asio::error::bad_descriptor;
        -:  688:    return socket_error_retval;
        -:  689:  }
        -:  690:
        -:  691:  clear_last_error();
        -:  692:  int result = error_wrapper(::listen(s, backlog), ec);
        -:  693:  if (result == 0)
        -:  694:    ec = boost::system::error_code();
        -:  695:  return result;
        -:  696:}
        -:  697:
        -:  698:inline void init_buf_iov_base(void*& base, void* addr)
        -:  699:{
        -:  700:  base = addr;
        -:  701:}
        -:  702:
        -:  703:template <typename T>
        -:  704:inline void init_buf_iov_base(T& base, void* addr)
        -:  705:{
        -:  706:  base = static_cast<T>(addr);
        -:  707:}
        -:  708:
        -:  709:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  710:typedef WSABUF buf;
        -:  711:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  712:typedef iovec buf;
        -:  713:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  714:
        -:  715:void init_buf(buf& b, void* data, size_t size)
        -:  716:{
        -:  717:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  718:  b.buf = static_cast<char*>(data);
        -:  719:  b.len = static_cast<u_long>(size);
        -:  720:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  721:  init_buf_iov_base(b.iov_base, data);
        -:  722:  b.iov_len = size;
        -:  723:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  724:}
        -:  725:
        -:  726:void init_buf(buf& b, const void* data, size_t size)
        -:  727:{
        -:  728:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  729:  b.buf = static_cast<char*>(const_cast<void*>(data));
        -:  730:  b.len = static_cast<u_long>(size);
        -:  731:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  732:  init_buf_iov_base(b.iov_base, const_cast<void*>(data));
        -:  733:  b.iov_len = size;
        -:  734:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  735:}
        -:  736:
        -:  737:inline void init_msghdr_msg_name(void*& name, socket_addr_type* addr)
        -:  738:{
        -:  739:  name = addr;
        -:  740:}
        -:  741:
        -:  742:inline void init_msghdr_msg_name(void*& name, const socket_addr_type* addr)
        -:  743:{
        -:  744:  name = const_cast<socket_addr_type*>(addr);
        -:  745:}
        -:  746:
        -:  747:template <typename T>
        -:  748:inline void init_msghdr_msg_name(T& name, socket_addr_type* addr)
        -:  749:{
        -:  750:  name = reinterpret_cast<T>(addr);
        -:  751:}
        -:  752:
        -:  753:template <typename T>
        -:  754:inline void init_msghdr_msg_name(T& name, const socket_addr_type* addr)
        -:  755:{
        -:  756:  name = reinterpret_cast<T>(const_cast<socket_addr_type*>(addr));
        -:  757:}
        -:  758:
        -:  759:signed_size_type recv(socket_type s, buf* bufs, size_t count,
        -:  760:    int flags, boost::system::error_code& ec)
        -:  761:{
        -:  762:  clear_last_error();
        -:  763:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  764:  // Receive some data.
        -:  765:  DWORD recv_buf_count = static_cast<DWORD>(count);
        -:  766:  DWORD bytes_transferred = 0;
        -:  767:  DWORD recv_flags = flags;
        -:  768:  int result = error_wrapper(::WSARecv(s, bufs,
        -:  769:        recv_buf_count, &bytes_transferred, &recv_flags, 0, 0), ec);
        -:  770:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  771:    ec = boost::asio::error::connection_reset;
        -:  772:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  773:    ec = boost::asio::error::connection_refused;
        -:  774:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -:  775:    ec.assign(0, ec.category());
        -:  776:  if (result != 0)
        -:  777:    return socket_error_retval;
        -:  778:  ec = boost::system::error_code();
        -:  779:  return bytes_transferred;
        -:  780:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  781:  msghdr msg = msghdr();
        -:  782:  msg.msg_iov = bufs;
        -:  783:  msg.msg_iovlen = static_cast<int>(count);
        -:  784:  signed_size_type result = error_wrapper(::recvmsg(s, &msg, flags), ec);
        -:  785:  if (result >= 0)
        -:  786:    ec = boost::system::error_code();
        -:  787:  return result;
        -:  788:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  789:}
        -:  790:
        -:  791:size_t sync_recv(socket_type s, state_type state, buf* bufs,
        -:  792:    size_t count, int flags, bool all_empty, boost::system::error_code& ec)
        -:  793:{
        -:  794:  if (s == invalid_socket)
        -:  795:  {
        -:  796:    ec = boost::asio::error::bad_descriptor;
        -:  797:    return 0;
        -:  798:  }
        -:  799:
        -:  800:  // A request to read 0 bytes on a stream is a no-op.
        -:  801:  if (all_empty && (state & stream_oriented))
        -:  802:  {
        -:  803:    ec = boost::system::error_code();
        -:  804:    return 0;
        -:  805:  }
        -:  806:
        -:  807:  // Read some data.
        -:  808:  for (;;)
        -:  809:  {
        -:  810:    // Try to complete the operation without blocking.
        -:  811:    signed_size_type bytes = socket_ops::recv(s, bufs, count, flags, ec);
        -:  812:
        -:  813:    // Check if operation succeeded.
        -:  814:    if (bytes > 0)
        -:  815:      return bytes;
        -:  816:
        -:  817:    // Check for EOF.
        -:  818:    if ((state & stream_oriented) && bytes == 0)
        -:  819:    {
        -:  820:      ec = boost::asio::error::eof;
        -:  821:      return 0;
        -:  822:    }
        -:  823:
        -:  824:    // Operation failed.
        -:  825:    if ((state & user_set_non_blocking)
        -:  826:        || (ec != boost::asio::error::would_block
        -:  827:          && ec != boost::asio::error::try_again))
        -:  828:      return 0;
        -:  829:
        -:  830:    // Wait for socket to become ready.
        -:  831:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -:  832:      return 0;
        -:  833:  }
        -:  834:}
        -:  835:
        -:  836:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  837:
        -:  838:void complete_iocp_recv(state_type state,
        -:  839:    const weak_cancel_token_type& cancel_token, bool all_empty,
        -:  840:    boost::system::error_code& ec, size_t bytes_transferred)
        -:  841:{
        -:  842:  // Map non-portable errors to their portable counterparts.
        -:  843:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  844:  {
        -:  845:    if (cancel_token.expired())
        -:  846:      ec = boost::asio::error::operation_aborted;
        -:  847:    else
        -:  848:      ec = boost::asio::error::connection_reset;
        -:  849:  }
        -:  850:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  851:  {
        -:  852:    ec = boost::asio::error::connection_refused;
        -:  853:  }
        -:  854:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -:  855:  {
        -:  856:    ec.assign(0, ec.category());
        -:  857:  }
        -:  858:
        -:  859:  // Check for connection closed.
        -:  860:  else if (!ec && bytes_transferred == 0
        -:  861:      && (state & stream_oriented) != 0
        -:  862:      && !all_empty)
        -:  863:  {
        -:  864:    ec = boost::asio::error::eof;
        -:  865:  }
        -:  866:}
        -:  867:
        -:  868:#else // defined(BOOST_ASIO_HAS_IOCP)
        -:  869:
        -:  870:bool non_blocking_recv(socket_type s,
        -:  871:    buf* bufs, size_t count, int flags, bool is_stream,
        -:  872:    boost::system::error_code& ec, size_t& bytes_transferred)
        -:  873:{
        -:  874:  for (;;)
        -:  875:  {
        -:  876:    // Read some data.
        -:  877:    signed_size_type bytes = socket_ops::recv(s, bufs, count, flags, ec);
        -:  878:
        -:  879:    // Check for end of stream.
        -:  880:    if (is_stream && bytes == 0)
        -:  881:    {
        -:  882:      ec = boost::asio::error::eof;
        -:  883:      return true;
        -:  884:    }
        -:  885:
        -:  886:    // Retry operation if interrupted by signal.
        -:  887:    if (ec == boost::asio::error::interrupted)
        -:  888:      continue;
        -:  889:
        -:  890:    // Check if we need to run the operation again.
        -:  891:    if (ec == boost::asio::error::would_block
        -:  892:        || ec == boost::asio::error::try_again)
        -:  893:      return false;
        -:  894:
        -:  895:    // Operation is complete.
        -:  896:    if (bytes >= 0)
        -:  897:    {
        -:  898:      ec = boost::system::error_code();
        -:  899:      bytes_transferred = bytes;
        -:  900:    }
        -:  901:    else
        -:  902:      bytes_transferred = 0;
        -:  903:
        -:  904:    return true;
        -:  905:  }
        -:  906:}
        -:  907:
        -:  908:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -:  909:
        -:  910:signed_size_type recvfrom(socket_type s, buf* bufs, size_t count,
        -:  911:    int flags, socket_addr_type* addr, std::size_t* addrlen,
        -:  912:    boost::system::error_code& ec)
        -:  913:{
        -:  914:  clear_last_error();
        -:  915:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  916:  // Receive some data.
        -:  917:  DWORD recv_buf_count = static_cast<DWORD>(count);
        -:  918:  DWORD bytes_transferred = 0;
        -:  919:  DWORD recv_flags = flags;
        -:  920:  int tmp_addrlen = (int)*addrlen;
        -:  921:  int result = error_wrapper(::WSARecvFrom(s, bufs, recv_buf_count,
        -:  922:        &bytes_transferred, &recv_flags, addr, &tmp_addrlen, 0, 0), ec);
        -:  923:  *addrlen = (std::size_t)tmp_addrlen;
        -:  924:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  925:    ec = boost::asio::error::connection_reset;
        -:  926:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  927:    ec = boost::asio::error::connection_refused;
        -:  928:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -:  929:    ec.assign(0, ec.category());
        -:  930:  if (result != 0)
        -:  931:    return socket_error_retval;
        -:  932:  ec = boost::system::error_code();
        -:  933:  return bytes_transferred;
        -:  934:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  935:  msghdr msg = msghdr();
        -:  936:  init_msghdr_msg_name(msg.msg_name, addr);
        -:  937:  msg.msg_namelen = static_cast<int>(*addrlen);
        -:  938:  msg.msg_iov = bufs;
        -:  939:  msg.msg_iovlen = static_cast<int>(count);
        -:  940:  signed_size_type result = error_wrapper(::recvmsg(s, &msg, flags), ec);
        -:  941:  *addrlen = msg.msg_namelen;
        -:  942:  if (result >= 0)
        -:  943:    ec = boost::system::error_code();
        -:  944:  return result;
        -:  945:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  946:}
        -:  947:
        -:  948:size_t sync_recvfrom(socket_type s, state_type state, buf* bufs,
        -:  949:    size_t count, int flags, socket_addr_type* addr,
        -:  950:    std::size_t* addrlen, boost::system::error_code& ec)
        -:  951:{
        -:  952:  if (s == invalid_socket)
        -:  953:  {
        -:  954:    ec = boost::asio::error::bad_descriptor;
        -:  955:    return 0;
        -:  956:  }
        -:  957:
        -:  958:  // Read some data.
        -:  959:  for (;;)
        -:  960:  {
        -:  961:    // Try to complete the operation without blocking.
        -:  962:    signed_size_type bytes = socket_ops::recvfrom(
        -:  963:        s, bufs, count, flags, addr, addrlen, ec);
        -:  964:
        -:  965:    // Check if operation succeeded.
        -:  966:    if (bytes >= 0)
        -:  967:      return bytes;
        -:  968:
        -:  969:    // Operation failed.
        -:  970:    if ((state & user_set_non_blocking)
        -:  971:        || (ec != boost::asio::error::would_block
        -:  972:          && ec != boost::asio::error::try_again))
        -:  973:      return 0;
        -:  974:
        -:  975:    // Wait for socket to become ready.
        -:  976:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -:  977:      return 0;
        -:  978:  }
        -:  979:}
        -:  980:
        -:  981:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  982:
        -:  983:void complete_iocp_recvfrom(
        -:  984:    const weak_cancel_token_type& cancel_token,
        -:  985:    boost::system::error_code& ec)
        -:  986:{
        -:  987:  // Map non-portable errors to their portable counterparts.
        -:  988:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  989:  {
        -:  990:    if (cancel_token.expired())
        -:  991:      ec = boost::asio::error::operation_aborted;
        -:  992:    else
        -:  993:      ec = boost::asio::error::connection_reset;
        -:  994:  }
        -:  995:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  996:  {
        -:  997:    ec = boost::asio::error::connection_refused;
        -:  998:  }
        -:  999:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -: 1000:  {
        -: 1001:    ec.assign(0, ec.category());
        -: 1002:  }
        -: 1003:}
        -: 1004:
        -: 1005:#else // defined(BOOST_ASIO_HAS_IOCP)
        -: 1006:
        -: 1007:bool non_blocking_recvfrom(socket_type s,
        -: 1008:    buf* bufs, size_t count, int flags,
        -: 1009:    socket_addr_type* addr, std::size_t* addrlen,
        -: 1010:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1011:{
        -: 1012:  for (;;)
        -: 1013:  {
        -: 1014:    // Read some data.
        -: 1015:    signed_size_type bytes = socket_ops::recvfrom(
        -: 1016:        s, bufs, count, flags, addr, addrlen, ec);
        -: 1017:
        -: 1018:    // Retry operation if interrupted by signal.
        -: 1019:    if (ec == boost::asio::error::interrupted)
        -: 1020:      continue;
        -: 1021:
        -: 1022:    // Check if we need to run the operation again.
        -: 1023:    if (ec == boost::asio::error::would_block
        -: 1024:        || ec == boost::asio::error::try_again)
        -: 1025:      return false;
        -: 1026:
        -: 1027:    // Operation is complete.
        -: 1028:    if (bytes >= 0)
        -: 1029:    {
        -: 1030:      ec = boost::system::error_code();
        -: 1031:      bytes_transferred = bytes;
        -: 1032:    }
        -: 1033:    else
        -: 1034:      bytes_transferred = 0;
        -: 1035:
        -: 1036:    return true;
        -: 1037:  }
        -: 1038:}
        -: 1039:
        -: 1040:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -: 1041:
        -: 1042:signed_size_type recvmsg(socket_type s, buf* bufs, size_t count,
        -: 1043:    int in_flags, int& out_flags, boost::system::error_code& ec)
        -: 1044:{
        -: 1045:  clear_last_error();
        -: 1046:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1047:  out_flags = 0;
        -: 1048:  return socket_ops::recv(s, bufs, count, in_flags, ec);
        -: 1049:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1050:  msghdr msg = msghdr();
        -: 1051:  msg.msg_iov = bufs;
        -: 1052:  msg.msg_iovlen = static_cast<int>(count);
        -: 1053:  signed_size_type result = error_wrapper(::recvmsg(s, &msg, in_flags), ec);
        -: 1054:  if (result >= 0)
        -: 1055:  {
        -: 1056:    ec = boost::system::error_code();
        -: 1057:    out_flags = msg.msg_flags;
        -: 1058:  }
        -: 1059:  else
        -: 1060:    out_flags = 0;
        -: 1061:  return result;
        -: 1062:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1063:}
        -: 1064:
        -: 1065:size_t sync_recvmsg(socket_type s, state_type state,
        -: 1066:    buf* bufs, size_t count, int in_flags, int& out_flags,
        -: 1067:    boost::system::error_code& ec)
        -: 1068:{
        -: 1069:  if (s == invalid_socket)
        -: 1070:  {
        -: 1071:    ec = boost::asio::error::bad_descriptor;
        -: 1072:    return 0;
        -: 1073:  }
        -: 1074:
        -: 1075:  // Read some data.
        -: 1076:  for (;;)
        -: 1077:  {
        -: 1078:    // Try to complete the operation without blocking.
        -: 1079:    signed_size_type bytes = socket_ops::recvmsg(
        -: 1080:        s, bufs, count, in_flags, out_flags, ec);
        -: 1081:
        -: 1082:    // Check if operation succeeded.
        -: 1083:    if (bytes >= 0)
        -: 1084:      return bytes;
        -: 1085:
        -: 1086:    // Operation failed.
        -: 1087:    if ((state & user_set_non_blocking)
        -: 1088:        || (ec != boost::asio::error::would_block
        -: 1089:          && ec != boost::asio::error::try_again))
        -: 1090:      return 0;
        -: 1091:
        -: 1092:    // Wait for socket to become ready.
        -: 1093:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -: 1094:      return 0;
        -: 1095:  }
        -: 1096:}
        -: 1097:
        -: 1098:#if defined(BOOST_ASIO_HAS_IOCP)
        -: 1099:
        -: 1100:void complete_iocp_recvmsg(
        -: 1101:    const weak_cancel_token_type& cancel_token,
        -: 1102:    boost::system::error_code& ec)
        -: 1103:{
        -: 1104:  // Map non-portable errors to their portable counterparts.
        -: 1105:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1106:  {
        -: 1107:    if (cancel_token.expired())
        -: 1108:      ec = boost::asio::error::operation_aborted;
        -: 1109:    else
        -: 1110:      ec = boost::asio::error::connection_reset;
        -: 1111:  }
        -: 1112:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1113:  {
        -: 1114:    ec = boost::asio::error::connection_refused;
        -: 1115:  }
        -: 1116:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -: 1117:  {
        -: 1118:    ec.assign(0, ec.category());
        -: 1119:  }
        -: 1120:}
        -: 1121:
        -: 1122:#else // defined(BOOST_ASIO_HAS_IOCP)
        -: 1123:
        -: 1124:bool non_blocking_recvmsg(socket_type s,
        -: 1125:    buf* bufs, size_t count, int in_flags, int& out_flags,
        -: 1126:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1127:{
        -: 1128:  for (;;)
        -: 1129:  {
        -: 1130:    // Read some data.
        -: 1131:    signed_size_type bytes = socket_ops::recvmsg(
        -: 1132:        s, bufs, count, in_flags, out_flags, ec);
        -: 1133:
        -: 1134:    // Retry operation if interrupted by signal.
        -: 1135:    if (ec == boost::asio::error::interrupted)
        -: 1136:      continue;
        -: 1137:
        -: 1138:    // Check if we need to run the operation again.
        -: 1139:    if (ec == boost::asio::error::would_block
        -: 1140:        || ec == boost::asio::error::try_again)
        -: 1141:      return false;
        -: 1142:
        -: 1143:    // Operation is complete.
        -: 1144:    if (bytes >= 0)
        -: 1145:    {
        -: 1146:      ec = boost::system::error_code();
        -: 1147:      bytes_transferred = bytes;
        -: 1148:    }
        -: 1149:    else
        -: 1150:      bytes_transferred = 0;
        -: 1151:
        -: 1152:    return true;
        -: 1153:  }
        -: 1154:}
        -: 1155:
        -: 1156:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -: 1157:
        -: 1158:signed_size_type send(socket_type s, const buf* bufs, size_t count,
        -: 1159:    int flags, boost::system::error_code& ec)
        -: 1160:{
        -: 1161:  clear_last_error();
        -: 1162:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1163:  // Send the data.
        -: 1164:  DWORD send_buf_count = static_cast<DWORD>(count);
        -: 1165:  DWORD bytes_transferred = 0;
        -: 1166:  DWORD send_flags = flags;
        -: 1167:  int result = error_wrapper(::WSASend(s, const_cast<buf*>(bufs),
        -: 1168:        send_buf_count, &bytes_transferred, send_flags, 0, 0), ec);
        -: 1169:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1170:    ec = boost::asio::error::connection_reset;
        -: 1171:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1172:    ec = boost::asio::error::connection_refused;
        -: 1173:  if (result != 0)
        -: 1174:    return socket_error_retval;
        -: 1175:  ec = boost::system::error_code();
        -: 1176:  return bytes_transferred;
        -: 1177:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1178:  msghdr msg = msghdr();
        -: 1179:  msg.msg_iov = const_cast<buf*>(bufs);
        -: 1180:  msg.msg_iovlen = static_cast<int>(count);
        -: 1181:#if defined(__linux__)
        -: 1182:  flags |= MSG_NOSIGNAL;
        -: 1183:#endif // defined(__linux__)
        -: 1184:  signed_size_type result = error_wrapper(::sendmsg(s, &msg, flags), ec);
        -: 1185:  if (result >= 0)
        -: 1186:    ec = boost::system::error_code();
        -: 1187:  return result;
        -: 1188:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1189:}
        -: 1190:
        -: 1191:size_t sync_send(socket_type s, state_type state, const buf* bufs,
        -: 1192:    size_t count, int flags, bool all_empty, boost::system::error_code& ec)
        -: 1193:{
        -: 1194:  if (s == invalid_socket)
        -: 1195:  {
        -: 1196:    ec = boost::asio::error::bad_descriptor;
        -: 1197:    return 0;
        -: 1198:  }
        -: 1199:
        -: 1200:  // A request to write 0 bytes to a stream is a no-op.
        -: 1201:  if (all_empty && (state & stream_oriented))
        -: 1202:  {
        -: 1203:    ec = boost::system::error_code();
        -: 1204:    return 0;
        -: 1205:  }
        -: 1206:
        -: 1207:  // Read some data.
        -: 1208:  for (;;)
        -: 1209:  {
        -: 1210:    // Try to complete the operation without blocking.
        -: 1211:    signed_size_type bytes = socket_ops::send(s, bufs, count, flags, ec);
        -: 1212:
        -: 1213:    // Check if operation succeeded.
        -: 1214:    if (bytes >= 0)
        -: 1215:      return bytes;
        -: 1216:
        -: 1217:    // Operation failed.
        -: 1218:    if ((state & user_set_non_blocking)
        -: 1219:        || (ec != boost::asio::error::would_block
        -: 1220:          && ec != boost::asio::error::try_again))
        -: 1221:      return 0;
        -: 1222:
        -: 1223:    // Wait for socket to become ready.
        -: 1224:    if (socket_ops::poll_write(s, 0, -1, ec) < 0)
        -: 1225:      return 0;
        -: 1226:  }
        -: 1227:}
        -: 1228:
        -: 1229:#if defined(BOOST_ASIO_HAS_IOCP)
        -: 1230:
        -: 1231:void complete_iocp_send(
        -: 1232:    const weak_cancel_token_type& cancel_token,
        -: 1233:    boost::system::error_code& ec)
        -: 1234:{
        -: 1235:  // Map non-portable errors to their portable counterparts.
        -: 1236:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1237:  {
        -: 1238:    if (cancel_token.expired())
        -: 1239:      ec = boost::asio::error::operation_aborted;
        -: 1240:    else
        -: 1241:      ec = boost::asio::error::connection_reset;
        -: 1242:  }
        -: 1243:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1244:  {
        -: 1245:    ec = boost::asio::error::connection_refused;
        -: 1246:  }
        -: 1247:}
        -: 1248:
        -: 1249:#else // defined(BOOST_ASIO_HAS_IOCP)
        -: 1250:
        -: 1251:bool non_blocking_send(socket_type s,
        -: 1252:    const buf* bufs, size_t count, int flags,
        -: 1253:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1254:{
        -: 1255:  for (;;)
        -: 1256:  {
        -: 1257:    // Write some data.
        -: 1258:    signed_size_type bytes = socket_ops::send(s, bufs, count, flags, ec);
        -: 1259:
        -: 1260:    // Retry operation if interrupted by signal.
        -: 1261:    if (ec == boost::asio::error::interrupted)
        -: 1262:      continue;
        -: 1263:
        -: 1264:    // Check if we need to run the operation again.
        -: 1265:    if (ec == boost::asio::error::would_block
        -: 1266:        || ec == boost::asio::error::try_again)
        -: 1267:      return false;
        -: 1268:
        -: 1269:    // Operation is complete.
        -: 1270:    if (bytes >= 0)
        -: 1271:    {
        -: 1272:      ec = boost::system::error_code();
        -: 1273:      bytes_transferred = bytes;
        -: 1274:    }
        -: 1275:    else
        -: 1276:      bytes_transferred = 0;
        -: 1277:
        -: 1278:    return true;
        -: 1279:  }
        -: 1280:}
        -: 1281:
        -: 1282:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -: 1283:
        -: 1284:signed_size_type sendto(socket_type s, const buf* bufs, size_t count,
        -: 1285:    int flags, const socket_addr_type* addr, std::size_t addrlen,
        -: 1286:    boost::system::error_code& ec)
        -: 1287:{
        -: 1288:  clear_last_error();
        -: 1289:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1290:  // Send the data.
        -: 1291:  DWORD send_buf_count = static_cast<DWORD>(count);
        -: 1292:  DWORD bytes_transferred = 0;
        -: 1293:  int result = error_wrapper(::WSASendTo(s, const_cast<buf*>(bufs),
        -: 1294:        send_buf_count, &bytes_transferred, flags, addr,
        -: 1295:        static_cast<int>(addrlen), 0, 0), ec);
        -: 1296:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1297:    ec = boost::asio::error::connection_reset;
        -: 1298:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1299:    ec = boost::asio::error::connection_refused;
        -: 1300:  if (result != 0)
        -: 1301:    return socket_error_retval;
        -: 1302:  ec = boost::system::error_code();
        -: 1303:  return bytes_transferred;
        -: 1304:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1305:  msghdr msg = msghdr();
        -: 1306:  init_msghdr_msg_name(msg.msg_name, addr);
        -: 1307:  msg.msg_namelen = static_cast<int>(addrlen);
        -: 1308:  msg.msg_iov = const_cast<buf*>(bufs);
        -: 1309:  msg.msg_iovlen = static_cast<int>(count);
        -: 1310:#if defined(__linux__)
        -: 1311:  flags |= MSG_NOSIGNAL;
        -: 1312:#endif // defined(__linux__)
        -: 1313:  signed_size_type result = error_wrapper(::sendmsg(s, &msg, flags), ec);
        -: 1314:  if (result >= 0)
        -: 1315:    ec = boost::system::error_code();
        -: 1316:  return result;
        -: 1317:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1318:}
        -: 1319:
        -: 1320:size_t sync_sendto(socket_type s, state_type state, const buf* bufs,
        -: 1321:    size_t count, int flags, const socket_addr_type* addr,
        -: 1322:    std::size_t addrlen, boost::system::error_code& ec)
        -: 1323:{
        -: 1324:  if (s == invalid_socket)
        -: 1325:  {
        -: 1326:    ec = boost::asio::error::bad_descriptor;
        -: 1327:    return 0;
        -: 1328:  }
        -: 1329:
        -: 1330:  // Write some data.
        -: 1331:  for (;;)
        -: 1332:  {
        -: 1333:    // Try to complete the operation without blocking.
        -: 1334:    signed_size_type bytes = socket_ops::sendto(
        -: 1335:        s, bufs, count, flags, addr, addrlen, ec);
        -: 1336:
        -: 1337:    // Check if operation succeeded.
        -: 1338:    if (bytes >= 0)
        -: 1339:      return bytes;
        -: 1340:
        -: 1341:    // Operation failed.
        -: 1342:    if ((state & user_set_non_blocking)
        -: 1343:        || (ec != boost::asio::error::would_block
        -: 1344:          && ec != boost::asio::error::try_again))
        -: 1345:      return 0;
        -: 1346:
        -: 1347:    // Wait for socket to become ready.
        -: 1348:    if (socket_ops::poll_write(s, 0, -1, ec) < 0)
        -: 1349:      return 0;
        -: 1350:  }
        -: 1351:}
        -: 1352:
        -: 1353:#if !defined(BOOST_ASIO_HAS_IOCP)
        -: 1354:
        -: 1355:bool non_blocking_sendto(socket_type s,
        -: 1356:    const buf* bufs, size_t count, int flags,
        -: 1357:    const socket_addr_type* addr, std::size_t addrlen,
        -: 1358:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1359:{
        -: 1360:  for (;;)
        -: 1361:  {
        -: 1362:    // Write some data.
        -: 1363:    signed_size_type bytes = socket_ops::sendto(
        -: 1364:        s, bufs, count, flags, addr, addrlen, ec);
        -: 1365:
        -: 1366:    // Retry operation if interrupted by signal.
        -: 1367:    if (ec == boost::asio::error::interrupted)
        -: 1368:      continue;
        -: 1369:
        -: 1370:    // Check if we need to run the operation again.
        -: 1371:    if (ec == boost::asio::error::would_block
        -: 1372:        || ec == boost::asio::error::try_again)
        -: 1373:      return false;
        -: 1374:
        -: 1375:    // Operation is complete.
        -: 1376:    if (bytes >= 0)
        -: 1377:    {
        -: 1378:      ec = boost::system::error_code();
        -: 1379:      bytes_transferred = bytes;
        -: 1380:    }
        -: 1381:    else
        -: 1382:      bytes_transferred = 0;
        -: 1383:
        -: 1384:    return true;
        -: 1385:  }
        -: 1386:}
        -: 1387:
        -: 1388:#endif // !defined(BOOST_ASIO_HAS_IOCP)
        -: 1389:
        -: 1390:socket_type socket(int af, int type, int protocol,
        -: 1391:    boost::system::error_code& ec)
        -: 1392:{
        -: 1393:  clear_last_error();
        -: 1394:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1395:  socket_type s = error_wrapper(::WSASocketW(af, type, protocol, 0, 0,
        -: 1396:        WSA_FLAG_OVERLAPPED), ec);
        -: 1397:  if (s == invalid_socket)
        -: 1398:    return s;
        -: 1399:
        -: 1400:  if (af == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 1401:  {
        -: 1402:    // Try to enable the POSIX default behaviour of having IPV6_V6ONLY set to
        -: 1403:    // false. This will only succeed on Windows Vista and later versions of
        -: 1404:    // Windows, where a dual-stack IPv4/v6 implementation is available.
        -: 1405:    DWORD optval = 0;
        -: 1406:    ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
        -: 1407:        reinterpret_cast<const char*>(&optval), sizeof(optval));
        -: 1408:  }
        -: 1409:
        -: 1410:  ec = boost::system::error_code();
        -: 1411:
        -: 1412:  return s;
        -: 1413:#elif defined(__MACH__) && defined(__APPLE__) || defined(__FreeBSD__)
        -: 1414:  socket_type s = error_wrapper(::socket(af, type, protocol), ec);
        -: 1415:  if (s == invalid_socket)
        -: 1416:    return s;
        -: 1417:
        -: 1418:  int optval = 1;
        -: 1419:  int result = error_wrapper(::setsockopt(s,
        -: 1420:        SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval)), ec);
        -: 1421:  if (result != 0)
        -: 1422:  {
        -: 1423:    ::close(s);
        -: 1424:    return invalid_socket;
        -: 1425:  }
        -: 1426:
        -: 1427:  return s;
        -: 1428:#else
        -: 1429:  int s = error_wrapper(::socket(af, type, protocol), ec);
        -: 1430:  if (s >= 0)
        -: 1431:    ec = boost::system::error_code();
        -: 1432:  return s;
        -: 1433:#endif
        -: 1434:}
        -: 1435:
        -: 1436:template <typename SockLenType>
    #####: 1437:inline int call_setsockopt(SockLenType msghdr::*,
        -: 1438:    socket_type s, int level, int optname,
        -: 1439:    const void* optval, std::size_t optlen)
        -: 1440:{
    #####: 1441:  return ::setsockopt(s, level, optname,
    #####: 1442:      (const char*)optval, (SockLenType)optlen);
        -: 1443:}
        -: 1444:
    #####: 1445:int setsockopt(socket_type s, state_type& state, int level, int optname,
        -: 1446:    const void* optval, std::size_t optlen, boost::system::error_code& ec)
        -: 1447:{
    #####: 1448:  if (s == invalid_socket)
        -: 1449:  {
    #####: 1450:    ec = boost::asio::error::bad_descriptor;
    #####: 1451:    return socket_error_retval;
        -: 1452:  }
        -: 1453:
    #####: 1454:  if (level == custom_socket_option_level && optname == always_fail_option)
        -: 1455:  {
    #####: 1456:    ec = boost::asio::error::invalid_argument;
    #####: 1457:    return socket_error_retval;
        -: 1458:  }
        -: 1459:
    #####: 1460:  if (level == custom_socket_option_level
    #####: 1461:      && optname == enable_connection_aborted_option)
        -: 1462:  {
    #####: 1463:    if (optlen != sizeof(int))
        -: 1464:    {
    #####: 1465:      ec = boost::asio::error::invalid_argument;
    #####: 1466:      return socket_error_retval;
        -: 1467:    }
        -: 1468:
    #####: 1469:    if (*static_cast<const int*>(optval))
    #####: 1470:      state |= enable_connection_aborted;
        -: 1471:    else
    #####: 1472:      state &= ~enable_connection_aborted;
    #####: 1473:    ec = boost::system::error_code();
    #####: 1474:    return 0;
        -: 1475:  }
        -: 1476:
    #####: 1477:  if (level == SOL_SOCKET && optname == SO_LINGER)
    #####: 1478:    state |= user_set_linger;
        -: 1479:
        -: 1480:#if defined(__BORLANDC__)
        -: 1481:  // Mysteriously, using the getsockopt and setsockopt functions directly with
        -: 1482:  // Borland C++ results in incorrect values being set and read. The bug can be
        -: 1483:  // worked around by using function addresses resolved with GetProcAddress.
        -: 1484:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 1485:  {
        -: 1486:    typedef int (WSAAPI *sso_t)(SOCKET, int, int, const char*, int);
        -: 1487:    if (sso_t sso = (sso_t)::GetProcAddress(winsock_module, "setsockopt"))
        -: 1488:    {
        -: 1489:      clear_last_error();
        -: 1490:      return error_wrapper(sso(s, level, optname,
        -: 1491:            reinterpret_cast<const char*>(optval),
        -: 1492:            static_cast<int>(optlen)), ec);
        -: 1493:    }
        -: 1494:  }
        -: 1495:  ec = boost::asio::error::fault;
        -: 1496:  return socket_error_retval;
        -: 1497:#else // defined(__BORLANDC__)
    #####: 1498:  clear_last_error();
    #####: 1499:  int result = error_wrapper(call_setsockopt(&msghdr::msg_namelen,
    #####: 1500:        s, level, optname, optval, optlen), ec);
    #####: 1501:  if (result == 0)
        -: 1502:  {
    #####: 1503:    ec = boost::system::error_code();
        -: 1504:
        -: 1505:#if defined(__MACH__) && defined(__APPLE__) \
        -: 1506:  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
        -: 1507:    // To implement portable behaviour for SO_REUSEADDR with UDP sockets we
        -: 1508:    // need to also set SO_REUSEPORT on BSD-based platforms.
        -: 1509:    if ((state & datagram_oriented)
        -: 1510:        && level == SOL_SOCKET && optname == SO_REUSEADDR)
        -: 1511:    {
        -: 1512:      call_setsockopt(&msghdr::msg_namelen, s,
        -: 1513:          SOL_SOCKET, SO_REUSEPORT, optval, optlen);
        -: 1514:    }
        -: 1515:#endif
        -: 1516:  }
        -: 1517:
    #####: 1518:  return result;
        -: 1519:#endif // defined(__BORLANDC__)
        -: 1520:}
        -: 1521:
        -: 1522:template <typename SockLenType>
        -: 1523:inline int call_getsockopt(SockLenType msghdr::*,
        -: 1524:    socket_type s, int level, int optname,
        -: 1525:    void* optval, std::size_t* optlen)
        -: 1526:{
        -: 1527:  SockLenType tmp_optlen = (SockLenType)*optlen;
        -: 1528:  int result = ::getsockopt(s, level, optname, (char*)optval, &tmp_optlen);
        -: 1529:  *optlen = (std::size_t)tmp_optlen;
        -: 1530:  return result;
        -: 1531:}
        -: 1532:
        -: 1533:int getsockopt(socket_type s, state_type state, int level, int optname,
        -: 1534:    void* optval, size_t* optlen, boost::system::error_code& ec)
        -: 1535:{
        -: 1536:  if (s == invalid_socket)
        -: 1537:  {
        -: 1538:    ec = boost::asio::error::bad_descriptor;
        -: 1539:    return socket_error_retval;
        -: 1540:  }
        -: 1541:
        -: 1542:  if (level == custom_socket_option_level && optname == always_fail_option)
        -: 1543:  {
        -: 1544:    ec = boost::asio::error::invalid_argument;
        -: 1545:    return socket_error_retval;
        -: 1546:  }
        -: 1547:
        -: 1548:  if (level == custom_socket_option_level
        -: 1549:      && optname == enable_connection_aborted_option)
        -: 1550:  {
        -: 1551:    if (*optlen != sizeof(int))
        -: 1552:    {
        -: 1553:      ec = boost::asio::error::invalid_argument;
        -: 1554:      return socket_error_retval;
        -: 1555:    }
        -: 1556:
        -: 1557:    *static_cast<int*>(optval) = (state & enable_connection_aborted) ? 1 : 0;
        -: 1558:    ec = boost::system::error_code();
        -: 1559:    return 0;
        -: 1560:  }
        -: 1561:
        -: 1562:#if defined(__BORLANDC__)
        -: 1563:  // Mysteriously, using the getsockopt and setsockopt functions directly with
        -: 1564:  // Borland C++ results in incorrect values being set and read. The bug can be
        -: 1565:  // worked around by using function addresses resolved with GetProcAddress.
        -: 1566:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 1567:  {
        -: 1568:    typedef int (WSAAPI *gso_t)(SOCKET, int, int, char*, int*);
        -: 1569:    if (gso_t gso = (gso_t)::GetProcAddress(winsock_module, "getsockopt"))
        -: 1570:    {
        -: 1571:      clear_last_error();
        -: 1572:      int tmp_optlen = static_cast<int>(*optlen);
        -: 1573:      int result = error_wrapper(gso(s, level, optname,
        -: 1574:            reinterpret_cast<char*>(optval), &tmp_optlen), ec);
        -: 1575:      *optlen = static_cast<size_t>(tmp_optlen);
        -: 1576:      if (result != 0 && level == IPPROTO_IPV6 && optname == IPV6_V6ONLY
        -: 1577:          && ec.value() == WSAENOPROTOOPT && *optlen == sizeof(DWORD))
        -: 1578:      {
        -: 1579:        // Dual-stack IPv4/v6 sockets, and the IPV6_V6ONLY socket option, are
        -: 1580:        // only supported on Windows Vista and later. To simplify program logic
        -: 1581:        // we will fake success of getting this option and specify that the
        -: 1582:        // value is non-zero (i.e. true). This corresponds to the behavior of
        -: 1583:        // IPv6 sockets on Windows platforms pre-Vista.
        -: 1584:        *static_cast<DWORD*>(optval) = 1;
        -: 1585:        ec = boost::system::error_code();
        -: 1586:      }
        -: 1587:      return result;
        -: 1588:    }
        -: 1589:  }
        -: 1590:  ec = boost::asio::error::fault;
        -: 1591:  return socket_error_retval;
        -: 1592:#elif defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1593:  clear_last_error();
        -: 1594:  int result = error_wrapper(call_getsockopt(&msghdr::msg_namelen,
        -: 1595:        s, level, optname, optval, optlen), ec);
        -: 1596:  if (result != 0 && level == IPPROTO_IPV6 && optname == IPV6_V6ONLY
        -: 1597:      && ec.value() == WSAENOPROTOOPT && *optlen == sizeof(DWORD))
        -: 1598:  {
        -: 1599:    // Dual-stack IPv4/v6 sockets, and the IPV6_V6ONLY socket option, are only
        -: 1600:    // supported on Windows Vista and later. To simplify program logic we will
        -: 1601:    // fake success of getting this option and specify that the value is
        -: 1602:    // non-zero (i.e. true). This corresponds to the behavior of IPv6 sockets
        -: 1603:    // on Windows platforms pre-Vista.
        -: 1604:    *static_cast<DWORD*>(optval) = 1;
        -: 1605:    ec = boost::system::error_code();
        -: 1606:  }
        -: 1607:  if (result == 0)
        -: 1608:    ec = boost::system::error_code();
        -: 1609:  return result;
        -: 1610:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1611:  clear_last_error();
        -: 1612:  int result = error_wrapper(call_getsockopt(&msghdr::msg_namelen,
        -: 1613:        s, level, optname, optval, optlen), ec);
        -: 1614:#if defined(__linux__)
        -: 1615:  if (result == 0 && level == SOL_SOCKET && *optlen == sizeof(int)
        -: 1616:      && (optname == SO_SNDBUF || optname == SO_RCVBUF))
        -: 1617:  {
        -: 1618:    // On Linux, setting SO_SNDBUF or SO_RCVBUF to N actually causes the kernel
        -: 1619:    // to set the buffer size to N*2. Linux puts additional stuff into the
        -: 1620:    // buffers so that only about half is actually available to the application.
        -: 1621:    // The retrieved value is divided by 2 here to make it appear as though the
        -: 1622:    // correct value has been set.
        -: 1623:    *static_cast<int*>(optval) /= 2;
        -: 1624:  }
        -: 1625:#endif // defined(__linux__)
        -: 1626:  if (result == 0)
        -: 1627:    ec = boost::system::error_code();
        -: 1628:  return result;
        -: 1629:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1630:}
        -: 1631:
        -: 1632:template <typename SockLenType>
        -: 1633:inline int call_getpeername(SockLenType msghdr::*,
        -: 1634:    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
        -: 1635:{
        -: 1636:  SockLenType tmp_addrlen = (SockLenType)*addrlen;
        -: 1637:  int result = ::getpeername(s, addr, &tmp_addrlen);
        -: 1638:  *addrlen = (std::size_t)tmp_addrlen;
        -: 1639:  return result;
        -: 1640:}
        -: 1641:
        -: 1642:int getpeername(socket_type s, socket_addr_type* addr,
        -: 1643:    std::size_t* addrlen, bool cached, boost::system::error_code& ec)
        -: 1644:{
        -: 1645:  if (s == invalid_socket)
        -: 1646:  {
        -: 1647:    ec = boost::asio::error::bad_descriptor;
        -: 1648:    return socket_error_retval;
        -: 1649:  }
        -: 1650:
        -: 1651:#if defined(BOOST_ASIO_WINDOWS) && !defined(BOOST_ASIO_WINDOWS_APP) \
        -: 1652:  || defined(__CYGWIN__)
        -: 1653:  if (cached)
        -: 1654:  {
        -: 1655:    // Check if socket is still connected.
        -: 1656:    DWORD connect_time = 0;
        -: 1657:    size_t connect_time_len = sizeof(connect_time);
        -: 1658:    if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_CONNECT_TIME,
        -: 1659:          &connect_time, &connect_time_len, ec) == socket_error_retval)
        -: 1660:    {
        -: 1661:      return socket_error_retval;
        -: 1662:    }
        -: 1663:    if (connect_time == 0xFFFFFFFF)
        -: 1664:    {
        -: 1665:      ec = boost::asio::error::not_connected;
        -: 1666:      return socket_error_retval;
        -: 1667:    }
        -: 1668:
        -: 1669:    // The cached value is still valid.
        -: 1670:    ec = boost::system::error_code();
        -: 1671:    return 0;
        -: 1672:  }
        -: 1673:#else // defined(BOOST_ASIO_WINDOWS) && !defined(BOOST_ASIO_WINDOWS_APP)
        -: 1674:      // || defined(__CYGWIN__)
        -: 1675:  (void)cached;
        -: 1676:#endif // defined(BOOST_ASIO_WINDOWS) && !defined(BOOST_ASIO_WINDOWS_APP)
        -: 1677:       // || defined(__CYGWIN__)
        -: 1678:
        -: 1679:  clear_last_error();
        -: 1680:  int result = error_wrapper(call_getpeername(
        -: 1681:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -: 1682:  if (result == 0)
        -: 1683:    ec = boost::system::error_code();
        -: 1684:  return result;
        -: 1685:}
        -: 1686:
        -: 1687:template <typename SockLenType>
        -: 1688:inline int call_getsockname(SockLenType msghdr::*,
        -: 1689:    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
        -: 1690:{
        -: 1691:  SockLenType tmp_addrlen = (SockLenType)*addrlen;
        -: 1692:  int result = ::getsockname(s, addr, &tmp_addrlen);
        -: 1693:  *addrlen = (std::size_t)tmp_addrlen;
        -: 1694:  return result;
        -: 1695:}
        -: 1696:
        -: 1697:int getsockname(socket_type s, socket_addr_type* addr,
        -: 1698:    std::size_t* addrlen, boost::system::error_code& ec)
        -: 1699:{
        -: 1700:  if (s == invalid_socket)
        -: 1701:  {
        -: 1702:    ec = boost::asio::error::bad_descriptor;
        -: 1703:    return socket_error_retval;
        -: 1704:  }
        -: 1705:
        -: 1706:  clear_last_error();
        -: 1707:  int result = error_wrapper(call_getsockname(
        -: 1708:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -: 1709:  if (result == 0)
        -: 1710:    ec = boost::system::error_code();
        -: 1711:  return result;
        -: 1712:}
        -: 1713:
        -: 1714:int ioctl(socket_type s, state_type& state, int cmd,
        -: 1715:    ioctl_arg_type* arg, boost::system::error_code& ec)
        -: 1716:{
        -: 1717:  if (s == invalid_socket)
        -: 1718:  {
        -: 1719:    ec = boost::asio::error::bad_descriptor;
        -: 1720:    return socket_error_retval;
        -: 1721:  }
        -: 1722:
        -: 1723:  clear_last_error();
        -: 1724:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1725:  int result = error_wrapper(::ioctlsocket(s, cmd, arg), ec);
        -: 1726:#elif defined(__MACH__) && defined(__APPLE__) \
        -: 1727:  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
        -: 1728:  int result = error_wrapper(::ioctl(s,
        -: 1729:        static_cast<unsigned int>(cmd), arg), ec);
        -: 1730:#else
        -: 1731:  int result = error_wrapper(::ioctl(s, cmd, arg), ec);
        -: 1732:#endif
        -: 1733:  if (result >= 0)
        -: 1734:  {
        -: 1735:    ec = boost::system::error_code();
        -: 1736:
        -: 1737:    // When updating the non-blocking mode we always perform the ioctl syscall,
        -: 1738:    // even if the flags would otherwise indicate that the socket is already in
        -: 1739:    // the correct state. This ensures that the underlying socket is put into
        -: 1740:    // the state that has been requested by the user. If the ioctl syscall was
        -: 1741:    // successful then we need to update the flags to match.
        -: 1742:    if (cmd == static_cast<int>(FIONBIO))
        -: 1743:    {
        -: 1744:      if (*arg)
        -: 1745:      {
        -: 1746:        state |= user_set_non_blocking;
        -: 1747:      }
        -: 1748:      else
        -: 1749:      {
        -: 1750:        // Clearing the non-blocking mode always overrides any internally-set
        -: 1751:        // non-blocking flag. Any subsequent asynchronous operations will need
        -: 1752:        // to re-enable non-blocking I/O.
        -: 1753:        state &= ~(user_set_non_blocking | internal_non_blocking);
        -: 1754:      }
        -: 1755:    }
        -: 1756:  }
        -: 1757:
        -: 1758:  return result;
        -: 1759:}
        -: 1760:
        -: 1761:int select(int nfds, fd_set* readfds, fd_set* writefds,
        -: 1762:    fd_set* exceptfds, timeval* timeout, boost::system::error_code& ec)
        -: 1763:{
        -: 1764:  clear_last_error();
        -: 1765:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1766:  if (!readfds && !writefds && !exceptfds && timeout)
        -: 1767:  {
        -: 1768:    DWORD milliseconds = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;
        -: 1769:    if (milliseconds == 0)
        -: 1770:      milliseconds = 1; // Force context switch.
        -: 1771:    ::Sleep(milliseconds);
        -: 1772:    ec = boost::system::error_code();
        -: 1773:    return 0;
        -: 1774:  }
        -: 1775:
        -: 1776:  // The select() call allows timeout values measured in microseconds, but the
        -: 1777:  // system clock (as wrapped by boost::posix_time::microsec_clock) typically
        -: 1778:  // has a resolution of 10 milliseconds. This can lead to a spinning select
        -: 1779:  // reactor, meaning increased CPU usage, when waiting for the earliest
        -: 1780:  // scheduled timeout if it's less than 10 milliseconds away. To avoid a tight
        -: 1781:  // spin we'll use a minimum timeout of 1 millisecond.
        -: 1782:  if (timeout && timeout->tv_sec == 0
        -: 1783:      && timeout->tv_usec > 0 && timeout->tv_usec < 1000)
        -: 1784:    timeout->tv_usec = 1000;
        -: 1785:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1786:
        -: 1787:#if defined(__hpux) && defined(__SELECT)
        -: 1788:  timespec ts;
        -: 1789:  ts.tv_sec = timeout ? timeout->tv_sec : 0;
        -: 1790:  ts.tv_nsec = timeout ? timeout->tv_usec * 1000 : 0;
        -: 1791:  return error_wrapper(::pselect(nfds, readfds,
        -: 1792:        writefds, exceptfds, timeout ? &ts : 0, 0), ec);
        -: 1793:#else
        -: 1794:  int result = error_wrapper(::select(nfds, readfds,
        -: 1795:        writefds, exceptfds, timeout), ec);
        -: 1796:  if (result >= 0)
        -: 1797:    ec = boost::system::error_code();
        -: 1798:  return result;
        -: 1799:#endif
        -: 1800:}
        -: 1801:
        -: 1802:int poll_read(socket_type s, state_type state,
        -: 1803:    int msec, boost::system::error_code& ec)
        -: 1804:{
        -: 1805:  if (s == invalid_socket)
        -: 1806:  {
        -: 1807:    ec = boost::asio::error::bad_descriptor;
        -: 1808:    return socket_error_retval;
        -: 1809:  }
        -: 1810:
        -: 1811:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1812:  || defined(__CYGWIN__) \
        -: 1813:  || defined(__SYMBIAN32__)
        -: 1814:  fd_set fds;
        -: 1815:  FD_ZERO(&fds);
        -: 1816:  FD_SET(s, &fds);
        -: 1817:  timeval timeout_obj;
        -: 1818:  timeval* timeout;
        -: 1819:  if (state & user_set_non_blocking)
        -: 1820:  {
        -: 1821:    timeout_obj.tv_sec = 0;
        -: 1822:    timeout_obj.tv_usec = 0;
        -: 1823:    timeout = &timeout_obj;
        -: 1824:  }
        -: 1825:  else if (msec >= 0)
        -: 1826:  {
        -: 1827:    timeout_obj.tv_sec = msec / 1000;
        -: 1828:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1829:    timeout = &timeout_obj;
        -: 1830:  }
        -: 1831:  else
        -: 1832:    timeout = 0;
        -: 1833:  clear_last_error();
        -: 1834:  int result = error_wrapper(::select(s + 1, &fds, 0, 0, timeout), ec);
        -: 1835:#else // defined(BOOST_ASIO_WINDOWS)
        -: 1836:      // || defined(__CYGWIN__)
        -: 1837:      // || defined(__SYMBIAN32__)
        -: 1838:  pollfd fds;
        -: 1839:  fds.fd = s;
        -: 1840:  fds.events = POLLIN;
        -: 1841:  fds.revents = 0;
        -: 1842:  int timeout = (state & user_set_non_blocking) ? 0 : msec;
        -: 1843:  clear_last_error();
        -: 1844:  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
        -: 1845:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 1846:       // || defined(__CYGWIN__)
        -: 1847:       // || defined(__SYMBIAN32__)
        -: 1848:  if (result == 0)
        -: 1849:    ec = (state & user_set_non_blocking)
        -: 1850:      ? boost::asio::error::would_block : boost::system::error_code();
        -: 1851:  else if (result > 0)
        -: 1852:    ec = boost::system::error_code();
        -: 1853:  return result;
        -: 1854:}
        -: 1855:
        -: 1856:int poll_write(socket_type s, state_type state,
        -: 1857:    int msec, boost::system::error_code& ec)
        -: 1858:{
        -: 1859:  if (s == invalid_socket)
        -: 1860:  {
        -: 1861:    ec = boost::asio::error::bad_descriptor;
        -: 1862:    return socket_error_retval;
        -: 1863:  }
        -: 1864:
        -: 1865:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1866:  || defined(__CYGWIN__) \
        -: 1867:  || defined(__SYMBIAN32__)
        -: 1868:  fd_set fds;
        -: 1869:  FD_ZERO(&fds);
        -: 1870:  FD_SET(s, &fds);
        -: 1871:  timeval timeout_obj;
        -: 1872:  timeval* timeout;
        -: 1873:  if (state & user_set_non_blocking)
        -: 1874:  {
        -: 1875:    timeout_obj.tv_sec = 0;
        -: 1876:    timeout_obj.tv_usec = 0;
        -: 1877:    timeout = &timeout_obj;
        -: 1878:  }
        -: 1879:  else if (msec >= 0)
        -: 1880:  {
        -: 1881:    timeout_obj.tv_sec = msec / 1000;
        -: 1882:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1883:    timeout = &timeout_obj;
        -: 1884:  }
        -: 1885:  else
        -: 1886:    timeout = 0;
        -: 1887:  clear_last_error();
        -: 1888:  int result = error_wrapper(::select(s + 1, 0, &fds, 0, timeout), ec);
        -: 1889:#else // defined(BOOST_ASIO_WINDOWS)
        -: 1890:      // || defined(__CYGWIN__)
        -: 1891:      // || defined(__SYMBIAN32__)
        -: 1892:  pollfd fds;
        -: 1893:  fds.fd = s;
        -: 1894:  fds.events = POLLOUT;
        -: 1895:  fds.revents = 0;
        -: 1896:  int timeout = (state & user_set_non_blocking) ? 0 : msec;
        -: 1897:  clear_last_error();
        -: 1898:  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
        -: 1899:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 1900:       // || defined(__CYGWIN__)
        -: 1901:       // || defined(__SYMBIAN32__)
        -: 1902:  if (result == 0)
        -: 1903:    ec = (state & user_set_non_blocking)
        -: 1904:      ? boost::asio::error::would_block : boost::system::error_code();
        -: 1905:  else if (result > 0)
        -: 1906:    ec = boost::system::error_code();
        -: 1907:  return result;
        -: 1908:}
        -: 1909:
        -: 1910:int poll_error(socket_type s, state_type state,
        -: 1911:    int msec, boost::system::error_code& ec)
        -: 1912:{
        -: 1913:  if (s == invalid_socket)
        -: 1914:  {
        -: 1915:    ec = boost::asio::error::bad_descriptor;
        -: 1916:    return socket_error_retval;
        -: 1917:  }
        -: 1918:
        -: 1919:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1920:  || defined(__CYGWIN__) \
        -: 1921:  || defined(__SYMBIAN32__)
        -: 1922:  fd_set fds;
        -: 1923:  FD_ZERO(&fds);
        -: 1924:  FD_SET(s, &fds);
        -: 1925:  timeval timeout_obj;
        -: 1926:  timeval* timeout;
        -: 1927:  if (state & user_set_non_blocking)
        -: 1928:  {
        -: 1929:    timeout_obj.tv_sec = 0;
        -: 1930:    timeout_obj.tv_usec = 0;
        -: 1931:    timeout = &timeout_obj;
        -: 1932:  }
        -: 1933:  else if (msec >= 0)
        -: 1934:  {
        -: 1935:    timeout_obj.tv_sec = msec / 1000;
        -: 1936:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1937:    timeout = &timeout_obj;
        -: 1938:  }
        -: 1939:  else
        -: 1940:    timeout = 0;
        -: 1941:  clear_last_error();
        -: 1942:  int result = error_wrapper(::select(s + 1, 0, 0, &fds, timeout), ec);
        -: 1943:#else // defined(BOOST_ASIO_WINDOWS)
        -: 1944:      // || defined(__CYGWIN__)
        -: 1945:      // || defined(__SYMBIAN32__)
        -: 1946:  pollfd fds;
        -: 1947:  fds.fd = s;
        -: 1948:  fds.events = POLLPRI | POLLERR | POLLHUP;
        -: 1949:  fds.revents = 0;
        -: 1950:  int timeout = (state & user_set_non_blocking) ? 0 : msec;
        -: 1951:  clear_last_error();
        -: 1952:  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
        -: 1953:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 1954:       // || defined(__CYGWIN__)
        -: 1955:       // || defined(__SYMBIAN32__)
        -: 1956:  if (result == 0)
        -: 1957:    ec = (state & user_set_non_blocking)
        -: 1958:      ? boost::asio::error::would_block : boost::system::error_code();
        -: 1959:  else if (result > 0)
        -: 1960:    ec = boost::system::error_code();
        -: 1961:  return result;
        -: 1962:}
        -: 1963:
        -: 1964:int poll_connect(socket_type s, int msec, boost::system::error_code& ec)
        -: 1965:{
        -: 1966:  if (s == invalid_socket)
        -: 1967:  {
        -: 1968:    ec = boost::asio::error::bad_descriptor;
        -: 1969:    return socket_error_retval;
        -: 1970:  }
        -: 1971:
        -: 1972:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1973:  || defined(__CYGWIN__) \
        -: 1974:  || defined(__SYMBIAN32__)
        -: 1975:  fd_set write_fds;
        -: 1976:  FD_ZERO(&write_fds);
        -: 1977:  FD_SET(s, &write_fds);
        -: 1978:  fd_set except_fds;
        -: 1979:  FD_ZERO(&except_fds);
        -: 1980:  FD_SET(s, &except_fds);
        -: 1981:  timeval timeout_obj;
        -: 1982:  timeval* timeout;
        -: 1983:  if (msec >= 0)
        -: 1984:  {
        -: 1985:    timeout_obj.tv_sec = msec / 1000;
        -: 1986:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1987:    timeout = &timeout_obj;
        -: 1988:  }
        -: 1989:  else
        -: 1990:    timeout = 0;
        -: 1991:  clear_last_error();
        -: 1992:  int result = error_wrapper(::select(
        -: 1993:        s + 1, 0, &write_fds, &except_fds, timeout), ec);
        -: 1994:  if (result >= 0)
        -: 1995:    ec = boost::system::error_code();
        -: 1996:  return result;
        -: 1997:#else // defined(BOOST_ASIO_WINDOWS)
        -: 1998:      // || defined(__CYGWIN__)
        -: 1999:      // || defined(__SYMBIAN32__)
        -: 2000:  pollfd fds;
        -: 2001:  fds.fd = s;
        -: 2002:  fds.events = POLLOUT;
        -: 2003:  fds.revents = 0;
        -: 2004:  clear_last_error();
        -: 2005:  int result = error_wrapper(::poll(&fds, 1, msec), ec);
        -: 2006:  if (result >= 0)
        -: 2007:    ec = boost::system::error_code();
        -: 2008:  return result;
        -: 2009:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 2010:       // || defined(__CYGWIN__)
        -: 2011:       // || defined(__SYMBIAN32__)
        -: 2012:}
        -: 2013:
        -: 2014:#endif // !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2015:
        -: 2016:const char* inet_ntop(int af, const void* src, char* dest, size_t length,
        -: 2017:    unsigned long scope_id, boost::system::error_code& ec)
        -: 2018:{
        -: 2019:  clear_last_error();
        -: 2020:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2021:  using namespace std; // For sprintf.
        -: 2022:  const unsigned char* bytes = static_cast<const unsigned char*>(src);
        -: 2023:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2024:  {
        -: 2025:    sprintf_s(dest, length, "%u.%u.%u.%u",
        -: 2026:        bytes[0], bytes[1], bytes[2], bytes[3]);
        -: 2027:    return dest;
        -: 2028:  }
        -: 2029:  else if (af == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2030:  {
        -: 2031:    size_t n = 0, b = 0, z = 0;
        -: 2032:    while (n < length && b < 16)
        -: 2033:    {
        -: 2034:      if (bytes[b] == 0 && bytes[b + 1] == 0 && z == 0)
        -: 2035:      {
        -: 2036:        do b += 2; while (b < 16 && bytes[b] == 0 && bytes[b + 1] == 0);
        -: 2037:        n += sprintf_s(dest + n, length - n, ":%s", b < 16 ? "" : ":"), ++z;
        -: 2038:      }
        -: 2039:      else
        -: 2040:      {
        -: 2041:        n += sprintf_s(dest + n, length - n, "%s%x", b ? ":" : "",
        -: 2042:            (static_cast<u_long_type>(bytes[b]) << 8) | bytes[b + 1]);
        -: 2043:        b += 2;
        -: 2044:      }
        -: 2045:    }
        -: 2046:    if (scope_id)
        -: 2047:      n += sprintf_s(dest + n, length - n, "%%%lu", scope_id);
        -: 2048:    return dest;
        -: 2049:  }
        -: 2050:  else
        -: 2051:  {
        -: 2052:    ec = boost::asio::error::address_family_not_supported;
        -: 2053:    return 0;
        -: 2054:  }
        -: 2055:#elif defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2056:  using namespace std; // For memcpy.
        -: 2057:
        -: 2058:  if (af != BOOST_ASIO_OS_DEF(AF_INET) && af != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2059:  {
        -: 2060:    ec = boost::asio::error::address_family_not_supported;
        -: 2061:    return 0;
        -: 2062:  }
        -: 2063:
        -: 2064:  union
        -: 2065:  {
        -: 2066:    socket_addr_type base;
        -: 2067:    sockaddr_storage_type storage;
        -: 2068:    sockaddr_in4_type v4;
        -: 2069:    sockaddr_in6_type v6;
        -: 2070:  } address;
        -: 2071:  DWORD address_length;
        -: 2072:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2073:  {
        -: 2074:    address_length = sizeof(sockaddr_in4_type);
        -: 2075:    address.v4.sin_family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2076:    address.v4.sin_port = 0;
        -: 2077:    memcpy(&address.v4.sin_addr, src, sizeof(in4_addr_type));
        -: 2078:  }
        -: 2079:  else // AF_INET6
        -: 2080:  {
        -: 2081:    address_length = sizeof(sockaddr_in6_type);
        -: 2082:    address.v6.sin6_family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2083:    address.v6.sin6_port = 0;
        -: 2084:    address.v6.sin6_flowinfo = 0;
        -: 2085:    address.v6.sin6_scope_id = scope_id;
        -: 2086:    memcpy(&address.v6.sin6_addr, src, sizeof(in6_addr_type));
        -: 2087:  }
        -: 2088:
        -: 2089:  DWORD string_length = static_cast<DWORD>(length);
        -: 2090:#if defined(BOOST_NO_ANSI_APIS) || (defined(_MSC_VER) && (_MSC_VER >= 1800))
        -: 2091:  LPWSTR string_buffer = (LPWSTR)_alloca(length * sizeof(WCHAR));
        -: 2092:  int result = error_wrapper(::WSAAddressToStringW(&address.base,
        -: 2093:        address_length, 0, string_buffer, &string_length), ec);
        -: 2094:  ::WideCharToMultiByte(CP_ACP, 0, string_buffer, -1,
        -: 2095:      dest, static_cast<int>(length), 0, 0);
        -: 2096:#else
        -: 2097:  int result = error_wrapper(::WSAAddressToStringA(
        -: 2098:        &address.base, address_length, 0, dest, &string_length), ec);
        -: 2099:#endif
        -: 2100:
        -: 2101:  // Windows may set error code on success.
        -: 2102:  if (result != socket_error_retval)
        -: 2103:    ec = boost::system::error_code();
        -: 2104:
        -: 2105:  // Windows may not set an error code on failure.
        -: 2106:  else if (result == socket_error_retval && !ec)
        -: 2107:    ec = boost::asio::error::invalid_argument;
        -: 2108:
        -: 2109:  return result == socket_error_retval ? 0 : dest;
        -: 2110:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2111:  const char* result = error_wrapper(::inet_ntop(
        -: 2112:        af, src, dest, static_cast<int>(length)), ec);
        -: 2113:  if (result == 0 && !ec)
        -: 2114:    ec = boost::asio::error::invalid_argument;
        -: 2115:  if (result != 0 && af == BOOST_ASIO_OS_DEF(AF_INET6) && scope_id != 0)
        -: 2116:  {
        -: 2117:    using namespace std; // For strcat and sprintf.
        -: 2118:    char if_name[IF_NAMESIZE + 1] = "%";
        -: 2119:    const in6_addr_type* ipv6_address = static_cast<const in6_addr_type*>(src);
        -: 2120:    bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
        -: 2121:        && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
        -: 2122:    bool is_multicast_link_local = ((ipv6_address->s6_addr[0] == 0xff)
        -: 2123:        && ((ipv6_address->s6_addr[1] & 0x0f) == 0x02));
        -: 2124:    if ((!is_link_local && !is_multicast_link_local)
        -: 2125:        || if_indextoname(static_cast<unsigned>(scope_id), if_name + 1) == 0)
        -: 2126:      sprintf(if_name + 1, "%lu", scope_id);
        -: 2127:    strcat(dest, if_name);
        -: 2128:  }
        -: 2129:  return result;
        -: 2130:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2131:}
        -: 2132:
        -: 2133:int inet_pton(int af, const char* src, void* dest,
        -: 2134:    unsigned long* scope_id, boost::system::error_code& ec)
        -: 2135:{
        -: 2136:  clear_last_error();
        -: 2137:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2138:  using namespace std; // For sscanf.
        -: 2139:  unsigned char* bytes = static_cast<unsigned char*>(dest);
        -: 2140:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2141:  {
        -: 2142:    unsigned int b0, b1, b2, b3;
        -: 2143:    if (sscanf_s(src, "%u.%u.%u.%u", &b0, &b1, &b2, &b3) != 4)
        -: 2144:    {
        -: 2145:      ec = boost::asio::error::invalid_argument;
        -: 2146:      return -1;
        -: 2147:    }
        -: 2148:    if (b0 > 255 || b1 > 255 || b2 > 255 || b3 > 255)
        -: 2149:    {
        -: 2150:      ec = boost::asio::error::invalid_argument;
        -: 2151:      return -1;
        -: 2152:    }
        -: 2153:    bytes[0] = static_cast<unsigned char>(b0);
        -: 2154:    bytes[1] = static_cast<unsigned char>(b1);
        -: 2155:    bytes[2] = static_cast<unsigned char>(b2);
        -: 2156:    bytes[3] = static_cast<unsigned char>(b3);
        -: 2157:    ec = boost::system::error_code();
        -: 2158:    return 1;
        -: 2159:  }
        -: 2160:  else if (af == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2161:  {
        -: 2162:    unsigned char* bytes = static_cast<unsigned char*>(dest);
        -: 2163:    std::memset(bytes, 0, 16);
        -: 2164:    unsigned char back_bytes[16] = { 0 };
        -: 2165:    int num_front_bytes = 0, num_back_bytes = 0;
        -: 2166:    const char* p = src;
        -: 2167:
        -: 2168:    enum { fword, fcolon, bword, scope, done } state = fword;
        -: 2169:    unsigned long current_word = 0;
        -: 2170:    while (state != done)
        -: 2171:    {
        -: 2172:      if (current_word > 0xFFFF)
        -: 2173:      {
        -: 2174:        ec = boost::asio::error::invalid_argument;
        -: 2175:        return -1;
        -: 2176:      }
        -: 2177:
        -: 2178:      switch (state)
        -: 2179:      {
        -: 2180:      case fword:
        -: 2181:        if (*p >= '0' && *p <= '9')
        -: 2182:          current_word = current_word * 16 + *p++ - '0';
        -: 2183:        else if (*p >= 'a' && *p <= 'f')
        -: 2184:          current_word = current_word * 16 + *p++ - 'a' + 10;
        -: 2185:        else if (*p >= 'A' && *p <= 'F')
        -: 2186:          current_word = current_word * 16 + *p++ - 'A' + 10;
        -: 2187:        else
        -: 2188:        {
        -: 2189:          if (num_front_bytes == 16)
        -: 2190:          {
        -: 2191:            ec = boost::asio::error::invalid_argument;
        -: 2192:            return -1;
        -: 2193:          }
        -: 2194:
        -: 2195:          bytes[num_front_bytes++] = (current_word >> 8) & 0xFF;
        -: 2196:          bytes[num_front_bytes++] = current_word & 0xFF;
        -: 2197:          current_word = 0;
        -: 2198:
        -: 2199:          if (*p == ':')
        -: 2200:            state = fcolon, ++p;
        -: 2201:          else if (*p == '%')
        -: 2202:            state = scope, ++p;
        -: 2203:          else if (*p == 0)
        -: 2204:            state = done;
        -: 2205:          else
        -: 2206:          {
        -: 2207:            ec = boost::asio::error::invalid_argument;
        -: 2208:            return -1;
        -: 2209:          }
        -: 2210:        }
        -: 2211:        break;
        -: 2212:
        -: 2213:      case fcolon:
        -: 2214:        if (*p == ':')
        -: 2215:          state = bword, ++p;
        -: 2216:        else
        -: 2217:          state = fword;
        -: 2218:        break;
        -: 2219:
        -: 2220:      case bword:
        -: 2221:        if (*p >= '0' && *p <= '9')
        -: 2222:          current_word = current_word * 16 + *p++ - '0';
        -: 2223:        else if (*p >= 'a' && *p <= 'f')
        -: 2224:          current_word = current_word * 16 + *p++ - 'a' + 10;
        -: 2225:        else if (*p >= 'A' && *p <= 'F')
        -: 2226:          current_word = current_word * 16 + *p++ - 'A' + 10;
        -: 2227:        else
        -: 2228:        {
        -: 2229:          if (num_front_bytes + num_back_bytes == 16)
        -: 2230:          {
        -: 2231:            ec = boost::asio::error::invalid_argument;
        -: 2232:            return -1;
        -: 2233:          }
        -: 2234:
        -: 2235:          back_bytes[num_back_bytes++] = (current_word >> 8) & 0xFF;
        -: 2236:          back_bytes[num_back_bytes++] = current_word & 0xFF;
        -: 2237:          current_word = 0;
        -: 2238:
        -: 2239:          if (*p == ':')
        -: 2240:            state = bword, ++p;
        -: 2241:          else if (*p == '%')
        -: 2242:            state = scope, ++p;
        -: 2243:          else if (*p == 0)
        -: 2244:            state = done;
        -: 2245:          else
        -: 2246:          {
        -: 2247:            ec = boost::asio::error::invalid_argument;
        -: 2248:            return -1;
        -: 2249:          }
        -: 2250:        }
        -: 2251:        break;
        -: 2252:
        -: 2253:      case scope:
        -: 2254:        if (*p >= '0' && *p <= '9')
        -: 2255:          current_word = current_word * 10 + *p++ - '0';
        -: 2256:        else if (*p == 0)
        -: 2257:          *scope_id = current_word, state = done;
        -: 2258:        else
        -: 2259:        {
        -: 2260:          ec = boost::asio::error::invalid_argument;
        -: 2261:          return -1;
        -: 2262:        }
        -: 2263:        break;
        -: 2264:
        -: 2265:      default:
        -: 2266:        break;
        -: 2267:      }
        -: 2268:    }
        -: 2269:
        -: 2270:    for (int i = 0; i < num_back_bytes; ++i)
        -: 2271:      bytes[16 - num_back_bytes + i] = back_bytes[i];
        -: 2272:
        -: 2273:    ec = boost::system::error_code();
        -: 2274:    return 1;
        -: 2275:  }
        -: 2276:  else
        -: 2277:  {
        -: 2278:    ec = boost::asio::error::address_family_not_supported;
        -: 2279:    return -1;
        -: 2280:  }
        -: 2281:#elif defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2282:  using namespace std; // For memcpy and strcmp.
        -: 2283:
        -: 2284:  if (af != BOOST_ASIO_OS_DEF(AF_INET) && af != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2285:  {
        -: 2286:    ec = boost::asio::error::address_family_not_supported;
        -: 2287:    return -1;
        -: 2288:  }
        -: 2289:
        -: 2290:  union
        -: 2291:  {
        -: 2292:    socket_addr_type base;
        -: 2293:    sockaddr_storage_type storage;
        -: 2294:    sockaddr_in4_type v4;
        -: 2295:    sockaddr_in6_type v6;
        -: 2296:  } address;
        -: 2297:  int address_length = sizeof(sockaddr_storage_type);
        -: 2298:#if defined(BOOST_NO_ANSI_APIS) || (defined(_MSC_VER) && (_MSC_VER >= 1800))
        -: 2299:  int num_wide_chars = static_cast<int>(strlen(src)) + 1;
        -: 2300:  LPWSTR wide_buffer = (LPWSTR)_alloca(num_wide_chars * sizeof(WCHAR));
        -: 2301:  ::MultiByteToWideChar(CP_ACP, 0, src, -1, wide_buffer, num_wide_chars);
        -: 2302:  int result = error_wrapper(::WSAStringToAddressW(
        -: 2303:        wide_buffer, af, 0, &address.base, &address_length), ec);
        -: 2304:#else
        -: 2305:  int result = error_wrapper(::WSAStringToAddressA(
        -: 2306:        const_cast<char*>(src), af, 0, &address.base, &address_length), ec);
        -: 2307:#endif
        -: 2308:
        -: 2309:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2310:  {
        -: 2311:    if (result != socket_error_retval)
        -: 2312:    {
        -: 2313:      memcpy(dest, &address.v4.sin_addr, sizeof(in4_addr_type));
        -: 2314:      ec = boost::system::error_code();
        -: 2315:    }
        -: 2316:    else if (strcmp(src, "255.255.255.255") == 0)
        -: 2317:    {
        -: 2318:      static_cast<in4_addr_type*>(dest)->s_addr = INADDR_NONE;
        -: 2319:      ec = boost::system::error_code();
        -: 2320:    }
        -: 2321:  }
        -: 2322:  else // AF_INET6
        -: 2323:  {
        -: 2324:    if (result != socket_error_retval)
        -: 2325:    {
        -: 2326:      memcpy(dest, &address.v6.sin6_addr, sizeof(in6_addr_type));
        -: 2327:      if (scope_id)
        -: 2328:        *scope_id = address.v6.sin6_scope_id;
        -: 2329:      ec = boost::system::error_code();
        -: 2330:    }
        -: 2331:  }
        -: 2332:
        -: 2333:  // Windows may not set an error code on failure.
        -: 2334:  if (result == socket_error_retval && !ec)
        -: 2335:    ec = boost::asio::error::invalid_argument;
        -: 2336:
        -: 2337:  if (result != socket_error_retval)
        -: 2338:    ec = boost::system::error_code();
        -: 2339:
        -: 2340:  return result == socket_error_retval ? -1 : 1;
        -: 2341:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2342:  using namespace std; // For strchr, memcpy and atoi.
        -: 2343:
        -: 2344:  // On some platforms, inet_pton fails if an address string contains a scope
        -: 2345:  // id. Detect and remove the scope id before passing the string to inet_pton.
        -: 2346:  const bool is_v6 = (af == BOOST_ASIO_OS_DEF(AF_INET6));
        -: 2347:  const char* if_name = is_v6 ? strchr(src, '%') : 0;
        -: 2348:  char src_buf[max_addr_v6_str_len + 1];
        -: 2349:  const char* src_ptr = src;
        -: 2350:  if (if_name != 0)
        -: 2351:  {
        -: 2352:    if (if_name - src > max_addr_v6_str_len)
        -: 2353:    {
        -: 2354:      ec = boost::asio::error::invalid_argument;
        -: 2355:      return 0;
        -: 2356:    }
        -: 2357:    memcpy(src_buf, src, if_name - src);
        -: 2358:    src_buf[if_name - src] = 0;
        -: 2359:    src_ptr = src_buf;
        -: 2360:  }
        -: 2361:
        -: 2362:  int result = error_wrapper(::inet_pton(af, src_ptr, dest), ec);
        -: 2363:  if (result <= 0 && !ec)
        -: 2364:    ec = boost::asio::error::invalid_argument;
        -: 2365:  if (result > 0 && is_v6 && scope_id)
        -: 2366:  {
        -: 2367:    using namespace std; // For strchr and atoi.
        -: 2368:    *scope_id = 0;
        -: 2369:    if (if_name != 0)
        -: 2370:    {
        -: 2371:      in6_addr_type* ipv6_address = static_cast<in6_addr_type*>(dest);
        -: 2372:      bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
        -: 2373:          && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
        -: 2374:      bool is_multicast_link_local = ((ipv6_address->s6_addr[0] == 0xff)
        -: 2375:          && ((ipv6_address->s6_addr[1] & 0x0f) == 0x02));
        -: 2376:      if (is_link_local || is_multicast_link_local)
        -: 2377:        *scope_id = if_nametoindex(if_name + 1);
        -: 2378:      if (*scope_id == 0)
        -: 2379:        *scope_id = atoi(if_name + 1);
        -: 2380:    }
        -: 2381:  }
        -: 2382:  return result;
        -: 2383:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2384:}
        -: 2385:
        -: 2386:int gethostname(char* name, int namelen, boost::system::error_code& ec)
        -: 2387:{
        -: 2388:  clear_last_error();
        -: 2389:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2390:  try
        -: 2391:  {
        -: 2392:    using namespace Windows::Foundation::Collections;
        -: 2393:    using namespace Windows::Networking;
        -: 2394:    using namespace Windows::Networking::Connectivity;
        -: 2395:    IVectorView<HostName^>^ hostnames = NetworkInformation::GetHostNames();
        -: 2396:    for (unsigned i = 0; i < hostnames->Size; ++i)
        -: 2397:    {
        -: 2398:      HostName^ hostname = hostnames->GetAt(i);
        -: 2399:      if (hostname->Type == HostNameType::DomainName)
        -: 2400:      {
        -: 2401:        std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
        -: 2402:        std::string raw_name = converter.to_bytes(hostname->RawName->Data());
        -: 2403:        if (namelen > 0 && raw_name.size() < static_cast<std::size_t>(namelen))
        -: 2404:        {
        -: 2405:          strcpy_s(name, namelen, raw_name.c_str());
        -: 2406:          return 0;
        -: 2407:        }
        -: 2408:      }
        -: 2409:    }
        -: 2410:    return -1;
        -: 2411:  }
        -: 2412:  catch (Platform::Exception^ e)
        -: 2413:  {
        -: 2414:    ec = boost::system::error_code(e->HResult,
        -: 2415:        boost::system::system_category());
        -: 2416:    return -1;
        -: 2417:  }
        -: 2418:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2419:  int result = error_wrapper(::gethostname(name, namelen), ec);
        -: 2420:# if defined(BOOST_ASIO_WINDOWS)
        -: 2421:  if (result == 0)
        -: 2422:    ec = boost::system::error_code();
        -: 2423:# endif // defined(BOOST_ASIO_WINDOWS)
        -: 2424:  return result;
        -: 2425:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2426:}
        -: 2427:
        -: 2428:#if !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2429:
        -: 2430:#if !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 2431:
        -: 2432:// The following functions are only needed for emulation of getaddrinfo and
        -: 2433:// getnameinfo.
        -: 2434:
        -: 2435:inline boost::system::error_code translate_netdb_error(int error)
        -: 2436:{
        -: 2437:  switch (error)
        -: 2438:  {
        -: 2439:  case 0:
        -: 2440:    return boost::system::error_code();
        -: 2441:  case HOST_NOT_FOUND:
        -: 2442:    return boost::asio::error::host_not_found;
        -: 2443:  case TRY_AGAIN:
        -: 2444:    return boost::asio::error::host_not_found_try_again;
        -: 2445:  case NO_RECOVERY:
        -: 2446:    return boost::asio::error::no_recovery;
        -: 2447:  case NO_DATA:
        -: 2448:    return boost::asio::error::no_data;
        -: 2449:  default:
        -: 2450:    BOOST_ASIO_ASSERT(false);
        -: 2451:    return boost::asio::error::invalid_argument;
        -: 2452:  }
        -: 2453:}
        -: 2454:
        -: 2455:inline hostent* gethostbyaddr(const char* addr, int length, int af,
        -: 2456:    hostent* result, char* buffer, int buflength, boost::system::error_code& ec)
        -: 2457:{
        -: 2458:  clear_last_error();
        -: 2459:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2460:  (void)(buffer);
        -: 2461:  (void)(buflength);
        -: 2462:  hostent* retval = error_wrapper(::gethostbyaddr(addr, length, af), ec);
        -: 2463:  if (!retval)
        -: 2464:    return 0;
        -: 2465:  ec = boost::system::error_code();
        -: 2466:  *result = *retval;
        -: 2467:  return retval;
        -: 2468:#elif defined(__sun) || defined(__QNX__)
        -: 2469:  int error = 0;
        -: 2470:  hostent* retval = error_wrapper(::gethostbyaddr_r(addr, length, af, result,
        -: 2471:        buffer, buflength, &error), ec);
        -: 2472:  if (error)
        -: 2473:    ec = translate_netdb_error(error);
        -: 2474:  return retval;
        -: 2475:#elif defined(__MACH__) && defined(__APPLE__)
        -: 2476:  (void)(buffer);
        -: 2477:  (void)(buflength);
        -: 2478:  int error = 0;
        -: 2479:  hostent* retval = error_wrapper(::getipnodebyaddr(
        -: 2480:        addr, length, af, &error), ec);
        -: 2481:  if (error)
        -: 2482:    ec = translate_netdb_error(error);
        -: 2483:  if (!retval)
        -: 2484:    return 0;
        -: 2485:  *result = *retval;
        -: 2486:  return retval;
        -: 2487:#else
        -: 2488:  hostent* retval = 0;
        -: 2489:  int error = 0;
        -: 2490:  error_wrapper(::gethostbyaddr_r(addr, length, af, result, buffer,
        -: 2491:        buflength, &retval, &error), ec);
        -: 2492:  if (error)
        -: 2493:    ec = translate_netdb_error(error);
        -: 2494:  return retval;
        -: 2495:#endif
        -: 2496:}
        -: 2497:
        -: 2498:inline hostent* gethostbyname(const char* name, int af, struct hostent* result,
        -: 2499:    char* buffer, int buflength, int ai_flags, boost::system::error_code& ec)
        -: 2500:{
        -: 2501:  clear_last_error();
        -: 2502:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2503:  (void)(buffer);
        -: 2504:  (void)(buflength);
        -: 2505:  (void)(ai_flags);
        -: 2506:  if (af != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2507:  {
        -: 2508:    ec = boost::asio::error::address_family_not_supported;
        -: 2509:    return 0;
        -: 2510:  }
        -: 2511:  hostent* retval = error_wrapper(::gethostbyname(name), ec);
        -: 2512:  if (!retval)
        -: 2513:    return 0;
        -: 2514:  ec = boost::system::error_code();
        -: 2515:  *result = *retval;
        -: 2516:  return result;
        -: 2517:#elif defined(__sun) || defined(__QNX__)
        -: 2518:  (void)(ai_flags);
        -: 2519:  if (af != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2520:  {
        -: 2521:    ec = boost::asio::error::address_family_not_supported;
        -: 2522:    return 0;
        -: 2523:  }
        -: 2524:  int error = 0;
        -: 2525:  hostent* retval = error_wrapper(::gethostbyname_r(name, result, buffer,
        -: 2526:        buflength, &error), ec);
        -: 2527:  if (error)
        -: 2528:    ec = translate_netdb_error(error);
        -: 2529:  return retval;
        -: 2530:#elif defined(__MACH__) && defined(__APPLE__)
        -: 2531:  (void)(buffer);
        -: 2532:  (void)(buflength);
        -: 2533:  int error = 0;
        -: 2534:  hostent* retval = error_wrapper(::getipnodebyname(
        -: 2535:        name, af, ai_flags, &error), ec);
        -: 2536:  if (error)
        -: 2537:    ec = translate_netdb_error(error);
        -: 2538:  if (!retval)
        -: 2539:    return 0;
        -: 2540:  *result = *retval;
        -: 2541:  return retval;
        -: 2542:#else
        -: 2543:  (void)(ai_flags);
        -: 2544:  if (af != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2545:  {
        -: 2546:    ec = boost::asio::error::address_family_not_supported;
        -: 2547:    return 0;
        -: 2548:  }
        -: 2549:  hostent* retval = 0;
        -: 2550:  int error = 0;
        -: 2551:  error_wrapper(::gethostbyname_r(name, result,
        -: 2552:        buffer, buflength, &retval, &error), ec);
        -: 2553:  if (error)
        -: 2554:    ec = translate_netdb_error(error);
        -: 2555:  return retval;
        -: 2556:#endif
        -: 2557:}
        -: 2558:
        -: 2559:inline void freehostent(hostent* h)
        -: 2560:{
        -: 2561:#if defined(__MACH__) && defined(__APPLE__)
        -: 2562:  if (h)
        -: 2563:    ::freehostent(h);
        -: 2564:#else
        -: 2565:  (void)(h);
        -: 2566:#endif
        -: 2567:}
        -: 2568:
        -: 2569:// Emulation of getaddrinfo based on implementation in:
        -: 2570:// Stevens, W. R., UNIX Network Programming Vol. 1, 2nd Ed., Prentice-Hall 1998.
        -: 2571:
        -: 2572:struct gai_search
        -: 2573:{
        -: 2574:  const char* host;
        -: 2575:  int family;
        -: 2576:};
        -: 2577:
        -: 2578:inline int gai_nsearch(const char* host,
        -: 2579:    const addrinfo_type* hints, gai_search (&search)[2])
        -: 2580:{
        -: 2581:  int search_count = 0;
        -: 2582:  if (host == 0 || host[0] == '\0')
        -: 2583:  {
        -: 2584:    if (hints->ai_flags & AI_PASSIVE)
        -: 2585:    {
        -: 2586:      // No host and AI_PASSIVE implies wildcard bind.
        -: 2587:      switch (hints->ai_family)
        -: 2588:      {
        -: 2589:      case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2590:        search[search_count].host = "0.0.0.0";
        -: 2591:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2592:        ++search_count;
        -: 2593:        break;
        -: 2594:      case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2595:        search[search_count].host = "0::0";
        -: 2596:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2597:        ++search_count;
        -: 2598:        break;
        -: 2599:      case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2600:        search[search_count].host = "0::0";
        -: 2601:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2602:        ++search_count;
        -: 2603:        search[search_count].host = "0.0.0.0";
        -: 2604:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2605:        ++search_count;
        -: 2606:        break;
        -: 2607:      default:
        -: 2608:        break;
        -: 2609:      }
        -: 2610:    }
        -: 2611:    else
        -: 2612:    {
        -: 2613:      // No host and not AI_PASSIVE means connect to local host.
        -: 2614:      switch (hints->ai_family)
        -: 2615:      {
        -: 2616:      case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2617:        search[search_count].host = "localhost";
        -: 2618:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2619:        ++search_count;
        -: 2620:        break;
        -: 2621:      case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2622:        search[search_count].host = "localhost";
        -: 2623:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2624:        ++search_count;
        -: 2625:        break;
        -: 2626:      case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2627:        search[search_count].host = "localhost";
        -: 2628:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2629:        ++search_count;
        -: 2630:        search[search_count].host = "localhost";
        -: 2631:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2632:        ++search_count;
        -: 2633:        break;
        -: 2634:      default:
        -: 2635:        break;
        -: 2636:      }
        -: 2637:    }
        -: 2638:  }
        -: 2639:  else
        -: 2640:  {
        -: 2641:    // Host is specified.
        -: 2642:    switch (hints->ai_family)
        -: 2643:    {
        -: 2644:    case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2645:      search[search_count].host = host;
        -: 2646:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2647:      ++search_count;
        -: 2648:      break;
        -: 2649:    case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2650:      search[search_count].host = host;
        -: 2651:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2652:      ++search_count;
        -: 2653:      break;
        -: 2654:    case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2655:      search[search_count].host = host;
        -: 2656:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2657:      ++search_count;
        -: 2658:      search[search_count].host = host;
        -: 2659:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2660:      ++search_count;
        -: 2661:      break;
        -: 2662:    default:
        -: 2663:      break;
        -: 2664:    }
        -: 2665:  }
        -: 2666:  return search_count;
        -: 2667:}
        -: 2668:
        -: 2669:template <typename T>
        -: 2670:inline T* gai_alloc(std::size_t size = sizeof(T))
        -: 2671:{
        -: 2672:  using namespace std;
        -: 2673:  T* p = static_cast<T*>(::operator new(size, std::nothrow));
        -: 2674:  if (p)
        -: 2675:    memset(p, 0, size);
        -: 2676:  return p;
        -: 2677:}
        -: 2678:
        -: 2679:inline void gai_free(void* p)
        -: 2680:{
        -: 2681:  ::operator delete(p);
        -: 2682:}
        -: 2683:
        -: 2684:inline void gai_strcpy(char* target, const char* source, std::size_t max_size)
        -: 2685:{
        -: 2686:  using namespace std;
        -: 2687:#if defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 2688:  strcpy_s(target, max_size, source);
        -: 2689:#else // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 2690:  *target = 0;
        -: 2691:  if (max_size > 0)
        -: 2692:    strncat(target, source, max_size - 1);
        -: 2693:#endif // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 2694:}
        -: 2695:
        -: 2696:enum { gai_clone_flag = 1 << 30 };
        -: 2697:
        -: 2698:inline int gai_aistruct(addrinfo_type*** next, const addrinfo_type* hints,
        -: 2699:    const void* addr, int family)
        -: 2700:{
        -: 2701:  using namespace std;
        -: 2702:
        -: 2703:  addrinfo_type* ai = gai_alloc<addrinfo_type>();
        -: 2704:  if (ai == 0)
        -: 2705:    return EAI_MEMORY;
        -: 2706:
        -: 2707:  ai->ai_next = 0;
        -: 2708:  **next = ai;
        -: 2709:  *next = &ai->ai_next;
        -: 2710:
        -: 2711:  ai->ai_canonname = 0;
        -: 2712:  ai->ai_socktype = hints->ai_socktype;
        -: 2713:  if (ai->ai_socktype == 0)
        -: 2714:    ai->ai_flags |= gai_clone_flag;
        -: 2715:  ai->ai_protocol = hints->ai_protocol;
        -: 2716:  ai->ai_family = family;
        -: 2717:
        -: 2718:  switch (ai->ai_family)
        -: 2719:  {
        -: 2720:  case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2721:    {
        -: 2722:      sockaddr_in4_type* sinptr = gai_alloc<sockaddr_in4_type>();
        -: 2723:      if (sinptr == 0)
        -: 2724:        return EAI_MEMORY;
        -: 2725:      sinptr->sin_family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2726:      memcpy(&sinptr->sin_addr, addr, sizeof(in4_addr_type));
        -: 2727:      ai->ai_addr = reinterpret_cast<sockaddr*>(sinptr);
        -: 2728:      ai->ai_addrlen = sizeof(sockaddr_in4_type);
        -: 2729:      break;
        -: 2730:    }
        -: 2731:  case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2732:    {
        -: 2733:      sockaddr_in6_type* sin6ptr = gai_alloc<sockaddr_in6_type>();
        -: 2734:      if (sin6ptr == 0)
        -: 2735:        return EAI_MEMORY;
        -: 2736:      sin6ptr->sin6_family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2737:      memcpy(&sin6ptr->sin6_addr, addr, sizeof(in6_addr_type));
        -: 2738:      ai->ai_addr = reinterpret_cast<sockaddr*>(sin6ptr);
        -: 2739:      ai->ai_addrlen = sizeof(sockaddr_in6_type);
        -: 2740:      break;
        -: 2741:    }
        -: 2742:  default:
        -: 2743:    break;
        -: 2744:  }
        -: 2745:
        -: 2746:  return 0;
        -: 2747:}
        -: 2748:
        -: 2749:inline addrinfo_type* gai_clone(addrinfo_type* ai)
        -: 2750:{
        -: 2751:  using namespace std;
        -: 2752:
        -: 2753:  addrinfo_type* new_ai = gai_alloc<addrinfo_type>();
        -: 2754:  if (new_ai == 0)
        -: 2755:    return new_ai;
        -: 2756:
        -: 2757:  new_ai->ai_next = ai->ai_next;
        -: 2758:  ai->ai_next = new_ai;
        -: 2759:
        -: 2760:  new_ai->ai_flags = 0;
        -: 2761:  new_ai->ai_family = ai->ai_family;
        -: 2762:  new_ai->ai_socktype = ai->ai_socktype;
        -: 2763:  new_ai->ai_protocol = ai->ai_protocol;
        -: 2764:  new_ai->ai_canonname = 0;
        -: 2765:  new_ai->ai_addrlen = ai->ai_addrlen;
        -: 2766:  new_ai->ai_addr = gai_alloc<sockaddr>(ai->ai_addrlen);
        -: 2767:  memcpy(new_ai->ai_addr, ai->ai_addr, ai->ai_addrlen);
        -: 2768:
        -: 2769:  return new_ai;
        -: 2770:}
        -: 2771:
        -: 2772:inline int gai_port(addrinfo_type* aihead, int port, int socktype)
        -: 2773:{
        -: 2774:  int num_found = 0;
        -: 2775:
        -: 2776:  for (addrinfo_type* ai = aihead; ai; ai = ai->ai_next)
        -: 2777:  {
        -: 2778:    if (ai->ai_flags & gai_clone_flag)
        -: 2779:    {
        -: 2780:      if (ai->ai_socktype != 0)
        -: 2781:      {
        -: 2782:        ai = gai_clone(ai);
        -: 2783:        if (ai == 0)
        -: 2784:          return -1;
        -: 2785:        // ai now points to newly cloned entry.
        -: 2786:      }
        -: 2787:    }
        -: 2788:    else if (ai->ai_socktype != socktype)
        -: 2789:    {
        -: 2790:      // Ignore if mismatch on socket type.
        -: 2791:      continue;
        -: 2792:    }
        -: 2793:
        -: 2794:    ai->ai_socktype = socktype;
        -: 2795:
        -: 2796:    switch (ai->ai_family)
        -: 2797:    {
        -: 2798:    case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2799:      {
        -: 2800:        sockaddr_in4_type* sinptr =
        -: 2801:          reinterpret_cast<sockaddr_in4_type*>(ai->ai_addr);
        -: 2802:        sinptr->sin_port = port;
        -: 2803:        ++num_found;
        -: 2804:        break;
        -: 2805:      }
        -: 2806:    case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2807:      {
        -: 2808:        sockaddr_in6_type* sin6ptr =
        -: 2809:          reinterpret_cast<sockaddr_in6_type*>(ai->ai_addr);
        -: 2810:        sin6ptr->sin6_port = port;
        -: 2811:        ++num_found;
        -: 2812:        break;
        -: 2813:      }
        -: 2814:    default:
        -: 2815:      break;
        -: 2816:    }
        -: 2817:  }
        -: 2818:
        -: 2819:  return num_found;
        -: 2820:}
        -: 2821:
        -: 2822:inline int gai_serv(addrinfo_type* aihead,
        -: 2823:    const addrinfo_type* hints, const char* serv)
        -: 2824:{
        -: 2825:  using namespace std;
        -: 2826:
        -: 2827:  int num_found = 0;
        -: 2828:
        -: 2829:  if (
        -: 2830:#if defined(AI_NUMERICSERV)
        -: 2831:      (hints->ai_flags & AI_NUMERICSERV) ||
        -: 2832:#endif
        -: 2833:      isdigit(static_cast<unsigned char>(serv[0])))
        -: 2834:  {
        -: 2835:    int port = htons(atoi(serv));
        -: 2836:    if (hints->ai_socktype)
        -: 2837:    {
        -: 2838:      // Caller specifies socket type.
        -: 2839:      int rc = gai_port(aihead, port, hints->ai_socktype);
        -: 2840:      if (rc < 0)
        -: 2841:        return EAI_MEMORY;
        -: 2842:      num_found += rc;
        -: 2843:    }
        -: 2844:    else
        -: 2845:    {
        -: 2846:      // Caller does not specify socket type.
        -: 2847:      int rc = gai_port(aihead, port, SOCK_STREAM);
        -: 2848:      if (rc < 0)
        -: 2849:        return EAI_MEMORY;
        -: 2850:      num_found += rc;
        -: 2851:      rc = gai_port(aihead, port, SOCK_DGRAM);
        -: 2852:      if (rc < 0)
        -: 2853:        return EAI_MEMORY;
        -: 2854:      num_found += rc;
        -: 2855:    }
        -: 2856:  }
        -: 2857:  else
        -: 2858:  {
        -: 2859:    // Try service name with TCP first, then UDP.
        -: 2860:    if (hints->ai_socktype == 0 || hints->ai_socktype == SOCK_STREAM)
        -: 2861:    {
        -: 2862:      servent* sptr = getservbyname(serv, "tcp");
        -: 2863:      if (sptr != 0)
        -: 2864:      {
        -: 2865:        int rc = gai_port(aihead, sptr->s_port, SOCK_STREAM);
        -: 2866:        if (rc < 0)
        -: 2867:          return EAI_MEMORY;
        -: 2868:        num_found += rc;
        -: 2869:      }
        -: 2870:    }
        -: 2871:    if (hints->ai_socktype == 0 || hints->ai_socktype == SOCK_DGRAM)
        -: 2872:    {
        -: 2873:      servent* sptr = getservbyname(serv, "udp");
        -: 2874:      if (sptr != 0)
        -: 2875:      {
        -: 2876:        int rc = gai_port(aihead, sptr->s_port, SOCK_DGRAM);
        -: 2877:        if (rc < 0)
        -: 2878:          return EAI_MEMORY;
        -: 2879:        num_found += rc;
        -: 2880:      }
        -: 2881:    }
        -: 2882:  }
        -: 2883:
        -: 2884:  if (num_found == 0)
        -: 2885:  {
        -: 2886:    if (hints->ai_socktype == 0)
        -: 2887:    {
        -: 2888:      // All calls to getservbyname() failed.
        -: 2889:      return EAI_NONAME;
        -: 2890:    }
        -: 2891:    else
        -: 2892:    {
        -: 2893:      // Service not supported for socket type.
        -: 2894:      return EAI_SERVICE;
        -: 2895:    }
        -: 2896:  }
        -: 2897:
        -: 2898:  return 0;
        -: 2899:}
        -: 2900:
        -: 2901:inline int gai_echeck(const char* host, const char* service,
        -: 2902:    int flags, int family, int socktype, int protocol)
        -: 2903:{
        -: 2904:  (void)(flags);
        -: 2905:  (void)(protocol);
        -: 2906:
        -: 2907:  // Host or service must be specified.
        -: 2908:  if (host == 0 || host[0] == '\0')
        -: 2909:    if (service == 0 || service[0] == '\0')
        -: 2910:      return EAI_NONAME;
        -: 2911:
        -: 2912:  // Check combination of family and socket type.
        -: 2913:  switch (family)
        -: 2914:  {
        -: 2915:  case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2916:    break;
        -: 2917:  case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2918:  case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2919:    if (service != 0 && service[0] != '\0')
        -: 2920:      if (socktype != 0 && socktype != SOCK_STREAM && socktype != SOCK_DGRAM)
        -: 2921:        return EAI_SOCKTYPE;
        -: 2922:    break;
        -: 2923:  default:
        -: 2924:    return EAI_FAMILY;
        -: 2925:  }
        -: 2926:
        -: 2927:  return 0;
        -: 2928:}
        -: 2929:
        -: 2930:inline void freeaddrinfo_emulation(addrinfo_type* aihead)
        -: 2931:{
        -: 2932:  addrinfo_type* ai = aihead;
        -: 2933:  while (ai)
        -: 2934:  {
        -: 2935:    gai_free(ai->ai_addr);
        -: 2936:    gai_free(ai->ai_canonname);
        -: 2937:    addrinfo_type* ainext = ai->ai_next;
        -: 2938:    gai_free(ai);
        -: 2939:    ai = ainext;
        -: 2940:  }
        -: 2941:}
        -: 2942:
        -: 2943:inline int getaddrinfo_emulation(const char* host, const char* service,
        -: 2944:    const addrinfo_type* hintsp, addrinfo_type** result)
        -: 2945:{
        -: 2946:  // Set up linked list of addrinfo structures.
        -: 2947:  addrinfo_type* aihead = 0;
        -: 2948:  addrinfo_type** ainext = &aihead;
        -: 2949:  char* canon = 0;
        -: 2950:
        -: 2951:  // Supply default hints if not specified by caller.
        -: 2952:  addrinfo_type hints = addrinfo_type();
        -: 2953:  hints.ai_family = BOOST_ASIO_OS_DEF(AF_UNSPEC);
        -: 2954:  if (hintsp)
        -: 2955:    hints = *hintsp;
        -: 2956:
        -: 2957:  // If the resolution is not specifically for AF_INET6, remove the AI_V4MAPPED
        -: 2958:  // and AI_ALL flags.
        -: 2959:#if defined(AI_V4MAPPED)
        -: 2960:  if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2961:    hints.ai_flags &= ~AI_V4MAPPED;
        -: 2962:#endif
        -: 2963:#if defined(AI_ALL)
        -: 2964:  if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2965:    hints.ai_flags &= ~AI_ALL;
        -: 2966:#endif
        -: 2967:
        -: 2968:  // Basic error checking.
        -: 2969:  int rc = gai_echeck(host, service, hints.ai_flags, hints.ai_family,
        -: 2970:      hints.ai_socktype, hints.ai_protocol);
        -: 2971:  if (rc != 0)
        -: 2972:  {
        -: 2973:    freeaddrinfo_emulation(aihead);
        -: 2974:    return rc;
        -: 2975:  }
        -: 2976:
        -: 2977:  gai_search search[2];
        -: 2978:  int search_count = gai_nsearch(host, &hints, search);
        -: 2979:  for (gai_search* sptr = search; sptr < search + search_count; ++sptr)
        -: 2980:  {
        -: 2981:    // Check for IPv4 dotted decimal string.
        -: 2982:    in4_addr_type inaddr;
        -: 2983:    boost::system::error_code ec;
        -: 2984:    if (socket_ops::inet_pton(BOOST_ASIO_OS_DEF(AF_INET),
        -: 2985:          sptr->host, &inaddr, 0, ec) == 1)
        -: 2986:    {
        -: 2987:      if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_UNSPEC)
        -: 2988:          && hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2989:      {
        -: 2990:        freeaddrinfo_emulation(aihead);
        -: 2991:        gai_free(canon);
        -: 2992:        return EAI_FAMILY;
        -: 2993:      }
        -: 2994:      if (sptr->family == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2995:      {
        -: 2996:        rc = gai_aistruct(&ainext, &hints, &inaddr, BOOST_ASIO_OS_DEF(AF_INET));
        -: 2997:        if (rc != 0)
        -: 2998:        {
        -: 2999:          freeaddrinfo_emulation(aihead);
        -: 3000:          gai_free(canon);
        -: 3001:          return rc;
        -: 3002:        }
        -: 3003:      }
        -: 3004:      continue;
        -: 3005:    }
        -: 3006:
        -: 3007:    // Check for IPv6 hex string.
        -: 3008:    in6_addr_type in6addr;
        -: 3009:    if (socket_ops::inet_pton(BOOST_ASIO_OS_DEF(AF_INET6),
        -: 3010:          sptr->host, &in6addr, 0, ec) == 1)
        -: 3011:    {
        -: 3012:      if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_UNSPEC)
        -: 3013:          && hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 3014:      {
        -: 3015:        freeaddrinfo_emulation(aihead);
        -: 3016:        gai_free(canon);
        -: 3017:        return EAI_FAMILY;
        -: 3018:      }
        -: 3019:      if (sptr->family == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 3020:      {
        -: 3021:        rc = gai_aistruct(&ainext, &hints, &in6addr,
        -: 3022:            BOOST_ASIO_OS_DEF(AF_INET6));
        -: 3023:        if (rc != 0)
        -: 3024:        {
        -: 3025:          freeaddrinfo_emulation(aihead);
        -: 3026:          gai_free(canon);
        -: 3027:          return rc;
        -: 3028:        }
        -: 3029:      }
        -: 3030:      continue;
        -: 3031:    }
        -: 3032:
        -: 3033:    // Look up hostname.
        -: 3034:    hostent hent;
        -: 3035:    char hbuf[8192] = "";
        -: 3036:    hostent* hptr = socket_ops::gethostbyname(sptr->host,
        -: 3037:        sptr->family, &hent, hbuf, sizeof(hbuf), hints.ai_flags, ec);
        -: 3038:    if (hptr == 0)
        -: 3039:    {
        -: 3040:      if (search_count == 2)
        -: 3041:      {
        -: 3042:        // Failure is OK if there are multiple searches.
        -: 3043:        continue;
        -: 3044:      }
        -: 3045:      freeaddrinfo_emulation(aihead);
        -: 3046:      gai_free(canon);
        -: 3047:      if (ec == boost::asio::error::host_not_found)
        -: 3048:        return EAI_NONAME;
        -: 3049:      if (ec == boost::asio::error::host_not_found_try_again)
        -: 3050:        return EAI_AGAIN;
        -: 3051:      if (ec == boost::asio::error::no_recovery)
        -: 3052:        return EAI_FAIL;
        -: 3053:      if (ec == boost::asio::error::no_data)
        -: 3054:        return EAI_NONAME;
        -: 3055:      return EAI_NONAME;
        -: 3056:    }
        -: 3057:
        -: 3058:    // Check for address family mismatch if one was specified.
        -: 3059:    if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_UNSPEC)
        -: 3060:        && hints.ai_family != hptr->h_addrtype)
        -: 3061:    {
        -: 3062:      freeaddrinfo_emulation(aihead);
        -: 3063:      gai_free(canon);
        -: 3064:      socket_ops::freehostent(hptr);
        -: 3065:      return EAI_FAMILY;
        -: 3066:    }
        -: 3067:
        -: 3068:    // Save canonical name first time.
        -: 3069:    if (host != 0 && host[0] != '\0' && hptr->h_name && hptr->h_name[0]
        -: 3070:        && (hints.ai_flags & AI_CANONNAME) && canon == 0)
        -: 3071:    {
        -: 3072:      std::size_t canon_len = strlen(hptr->h_name) + 1;
        -: 3073:      canon = gai_alloc<char>(canon_len);
        -: 3074:      if (canon == 0)
        -: 3075:      {
        -: 3076:        freeaddrinfo_emulation(aihead);
        -: 3077:        socket_ops::freehostent(hptr);
        -: 3078:        return EAI_MEMORY;
        -: 3079:      }
        -: 3080:      gai_strcpy(canon, hptr->h_name, canon_len);
        -: 3081:    }
        -: 3082:
        -: 3083:    // Create an addrinfo structure for each returned address.
        -: 3084:    for (char** ap = hptr->h_addr_list; *ap; ++ap)
        -: 3085:    {
        -: 3086:      rc = gai_aistruct(&ainext, &hints, *ap, hptr->h_addrtype);
        -: 3087:      if (rc != 0)
        -: 3088:      {
        -: 3089:        freeaddrinfo_emulation(aihead);
        -: 3090:        gai_free(canon);
        -: 3091:        socket_ops::freehostent(hptr);
        -: 3092:        return EAI_FAMILY;
        -: 3093:      }
        -: 3094:    }
        -: 3095:
        -: 3096:    socket_ops::freehostent(hptr);
        -: 3097:  }
        -: 3098:
        -: 3099:  // Check if we found anything.
        -: 3100:  if (aihead == 0)
        -: 3101:  {
        -: 3102:    gai_free(canon);
        -: 3103:    return EAI_NONAME;
        -: 3104:  }
        -: 3105:
        -: 3106:  // Return canonical name in first entry.
        -: 3107:  if (host != 0 && host[0] != '\0' && (hints.ai_flags & AI_CANONNAME))
        -: 3108:  {
        -: 3109:    if (canon)
        -: 3110:    {
        -: 3111:      aihead->ai_canonname = canon;
        -: 3112:      canon = 0;
        -: 3113:    }
        -: 3114:    else
        -: 3115:    {
        -: 3116:      std::size_t canonname_len = strlen(search[0].host) + 1;
        -: 3117:      aihead->ai_canonname = gai_alloc<char>(canonname_len);
        -: 3118:      if (aihead->ai_canonname == 0)
        -: 3119:      {
        -: 3120:        freeaddrinfo_emulation(aihead);
        -: 3121:        return EAI_MEMORY;
        -: 3122:      }
        -: 3123:      gai_strcpy(aihead->ai_canonname, search[0].host, canonname_len);
        -: 3124:    }
        -: 3125:  }
        -: 3126:  gai_free(canon);
        -: 3127:
        -: 3128:  // Process the service name.
        -: 3129:  if (service != 0 && service[0] != '\0')
        -: 3130:  {
        -: 3131:    rc = gai_serv(aihead, &hints, service);
        -: 3132:    if (rc != 0)
        -: 3133:    {
        -: 3134:      freeaddrinfo_emulation(aihead);
        -: 3135:      return rc;
        -: 3136:    }
        -: 3137:  }
        -: 3138:
        -: 3139:  // Return result to caller.
        -: 3140:  *result = aihead;
        -: 3141:  return 0;
        -: 3142:}
        -: 3143:
        -: 3144:inline boost::system::error_code getnameinfo_emulation(
        -: 3145:    const socket_addr_type* sa, std::size_t salen, char* host,
        -: 3146:    std::size_t hostlen, char* serv, std::size_t servlen, int flags,
        -: 3147:    boost::system::error_code& ec)
        -: 3148:{
        -: 3149:  using namespace std;
        -: 3150:
        -: 3151:  const char* addr;
        -: 3152:  size_t addr_len;
        -: 3153:  unsigned short port;
        -: 3154:  switch (sa->sa_family)
        -: 3155:  {
        -: 3156:  case BOOST_ASIO_OS_DEF(AF_INET):
        -: 3157:    if (salen != sizeof(sockaddr_in4_type))
        -: 3158:    {
        -: 3159:      return ec = boost::asio::error::invalid_argument;
        -: 3160:    }
        -: 3161:    addr = reinterpret_cast<const char*>(
        -: 3162:        &reinterpret_cast<const sockaddr_in4_type*>(sa)->sin_addr);
        -: 3163:    addr_len = sizeof(in4_addr_type);
        -: 3164:    port = reinterpret_cast<const sockaddr_in4_type*>(sa)->sin_port;
        -: 3165:    break;
        -: 3166:  case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 3167:    if (salen != sizeof(sockaddr_in6_type))
        -: 3168:    {
        -: 3169:      return ec = boost::asio::error::invalid_argument;
        -: 3170:    }
        -: 3171:    addr = reinterpret_cast<const char*>(
        -: 3172:        &reinterpret_cast<const sockaddr_in6_type*>(sa)->sin6_addr);
        -: 3173:    addr_len = sizeof(in6_addr_type);
        -: 3174:    port = reinterpret_cast<const sockaddr_in6_type*>(sa)->sin6_port;
        -: 3175:    break;
        -: 3176:  default:
        -: 3177:    return ec = boost::asio::error::address_family_not_supported;
        -: 3178:  }
        -: 3179:
        -: 3180:  if (host && hostlen > 0)
        -: 3181:  {
        -: 3182:    if (flags & NI_NUMERICHOST)
        -: 3183:    {
        -: 3184:      if (socket_ops::inet_ntop(sa->sa_family, addr, host, hostlen, 0, ec) == 0)
        -: 3185:      {
        -: 3186:        return ec;
        -: 3187:      }
        -: 3188:    }
        -: 3189:    else
        -: 3190:    {
        -: 3191:      hostent hent;
        -: 3192:      char hbuf[8192] = "";
        -: 3193:      hostent* hptr = socket_ops::gethostbyaddr(addr,
        -: 3194:          static_cast<int>(addr_len), sa->sa_family,
        -: 3195:          &hent, hbuf, sizeof(hbuf), ec);
        -: 3196:      if (hptr && hptr->h_name && hptr->h_name[0] != '\0')
        -: 3197:      {
        -: 3198:        if (flags & NI_NOFQDN)
        -: 3199:        {
        -: 3200:          char* dot = strchr(hptr->h_name, '.');
        -: 3201:          if (dot)
        -: 3202:          {
        -: 3203:            *dot = 0;
        -: 3204:          }
        -: 3205:        }
        -: 3206:        gai_strcpy(host, hptr->h_name, hostlen);
        -: 3207:        socket_ops::freehostent(hptr);
        -: 3208:      }
        -: 3209:      else
        -: 3210:      {
        -: 3211:        socket_ops::freehostent(hptr);
        -: 3212:        if (flags & NI_NAMEREQD)
        -: 3213:        {
        -: 3214:          return ec = boost::asio::error::host_not_found;
        -: 3215:        }
        -: 3216:        if (socket_ops::inet_ntop(sa->sa_family,
        -: 3217:              addr, host, hostlen, 0, ec) == 0)
        -: 3218:        {
        -: 3219:          return ec;
        -: 3220:        }
        -: 3221:      }
        -: 3222:    }
        -: 3223:  }
        -: 3224:
        -: 3225:  if (serv && servlen > 0)
        -: 3226:  {
        -: 3227:    if (flags & NI_NUMERICSERV)
        -: 3228:    {
        -: 3229:      if (servlen < 6)
        -: 3230:      {
        -: 3231:        return ec = boost::asio::error::no_buffer_space;
        -: 3232:      }
        -: 3233:#if defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3234:      sprintf_s(serv, servlen, "%u", ntohs(port));
        -: 3235:#else // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3236:      sprintf(serv, "%u", ntohs(port));
        -: 3237:#endif // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3238:    }
        -: 3239:    else
        -: 3240:    {
        -: 3241:#if defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3242:      static ::pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
        -: 3243:      ::pthread_mutex_lock(&mutex);
        -: 3244:#endif // defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3245:      servent* sptr = ::getservbyport(port, (flags & NI_DGRAM) ? "udp" : 0);
        -: 3246:      if (sptr && sptr->s_name && sptr->s_name[0] != '\0')
        -: 3247:      {
        -: 3248:        gai_strcpy(serv, sptr->s_name, servlen);
        -: 3249:      }
        -: 3250:      else
        -: 3251:      {
        -: 3252:        if (servlen < 6)
        -: 3253:        {
        -: 3254:          return ec = boost::asio::error::no_buffer_space;
        -: 3255:        }
        -: 3256:#if defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3257:        sprintf_s(serv, servlen, "%u", ntohs(port));
        -: 3258:#else // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3259:        sprintf(serv, "%u", ntohs(port));
        -: 3260:#endif // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3261:      }
        -: 3262:#if defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3263:      ::pthread_mutex_unlock(&mutex);
        -: 3264:#endif // defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3265:    }
        -: 3266:  }
        -: 3267:
        -: 3268:  ec = boost::system::error_code();
        -: 3269:  return ec;
        -: 3270:}
        -: 3271:
        -: 3272:#endif // !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3273:
        -: 3274:inline boost::system::error_code translate_addrinfo_error(int error)
        -: 3275:{
        -: 3276:  switch (error)
        -: 3277:  {
        -: 3278:  case 0:
        -: 3279:    return boost::system::error_code();
        -: 3280:  case EAI_AGAIN:
        -: 3281:    return boost::asio::error::host_not_found_try_again;
        -: 3282:  case EAI_BADFLAGS:
        -: 3283:    return boost::asio::error::invalid_argument;
        -: 3284:  case EAI_FAIL:
        -: 3285:    return boost::asio::error::no_recovery;
        -: 3286:  case EAI_FAMILY:
        -: 3287:    return boost::asio::error::address_family_not_supported;
        -: 3288:  case EAI_MEMORY:
        -: 3289:    return boost::asio::error::no_memory;
        -: 3290:  case EAI_NONAME:
        -: 3291:#if defined(EAI_ADDRFAMILY)
        -: 3292:  case EAI_ADDRFAMILY:
        -: 3293:#endif
        -: 3294:#if defined(EAI_NODATA) && (EAI_NODATA != EAI_NONAME)
        -: 3295:  case EAI_NODATA:
        -: 3296:#endif
        -: 3297:    return boost::asio::error::host_not_found;
        -: 3298:  case EAI_SERVICE:
        -: 3299:    return boost::asio::error::service_not_found;
        -: 3300:  case EAI_SOCKTYPE:
        -: 3301:    return boost::asio::error::socket_type_not_supported;
        -: 3302:  default: // Possibly the non-portable EAI_SYSTEM.
        -: 3303:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3304:    return boost::system::error_code(
        -: 3305:        WSAGetLastError(), boost::asio::error::get_system_category());
        -: 3306:#else
        -: 3307:    return boost::system::error_code(
        -: 3308:        errno, boost::asio::error::get_system_category());
        -: 3309:#endif
        -: 3310:  }
        -: 3311:}
        -: 3312:
        -: 3313:boost::system::error_code getaddrinfo(const char* host,
        -: 3314:    const char* service, const addrinfo_type& hints,
        -: 3315:    addrinfo_type** result, boost::system::error_code& ec)
        -: 3316:{
        -: 3317:  host = (host && *host) ? host : 0;
        -: 3318:  service = (service && *service) ? service : 0;
        -: 3319:  clear_last_error();
        -: 3320:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3321:# if defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3322:  // Building for Windows XP, Windows Server 2003, or later.
        -: 3323:  int error = ::getaddrinfo(host, service, &hints, result);
        -: 3324:  return ec = translate_addrinfo_error(error);
        -: 3325:# else
        -: 3326:  // Building for Windows 2000 or earlier.
        -: 3327:  typedef int (WSAAPI *gai_t)(const char*,
        -: 3328:      const char*, const addrinfo_type*, addrinfo_type**);
        -: 3329:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 3330:  {
        -: 3331:    if (gai_t gai = (gai_t)::GetProcAddress(winsock_module, "getaddrinfo"))
        -: 3332:    {
        -: 3333:      int error = gai(host, service, &hints, result);
        -: 3334:      return ec = translate_addrinfo_error(error);
        -: 3335:    }
        -: 3336:  }
        -: 3337:  int error = getaddrinfo_emulation(host, service, &hints, result);
        -: 3338:  return ec = translate_addrinfo_error(error);
        -: 3339:# endif
        -: 3340:#elif !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3341:  int error = getaddrinfo_emulation(host, service, &hints, result);
        -: 3342:  return ec = translate_addrinfo_error(error);
        -: 3343:#else
        -: 3344:  int error = ::getaddrinfo(host, service, &hints, result);
        -: 3345:#if defined(__MACH__) && defined(__APPLE__)
        -: 3346:  using namespace std; // For isdigit and atoi.
        -: 3347:  if (error == 0 && service && isdigit(static_cast<unsigned char>(service[0])))
        -: 3348:  {
        -: 3349:    u_short_type port = host_to_network_short(atoi(service));
        -: 3350:    for (addrinfo_type* ai = *result; ai; ai = ai->ai_next)
        -: 3351:    {
        -: 3352:      switch (ai->ai_family)
        -: 3353:      {
        -: 3354:      case BOOST_ASIO_OS_DEF(AF_INET):
        -: 3355:        {
        -: 3356:          sockaddr_in4_type* sinptr =
        -: 3357:            reinterpret_cast<sockaddr_in4_type*>(ai->ai_addr);
        -: 3358:          if (sinptr->sin_port == 0)
        -: 3359:            sinptr->sin_port = port;
        -: 3360:          break;
        -: 3361:        }
        -: 3362:      case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 3363:        {
        -: 3364:          sockaddr_in6_type* sin6ptr =
        -: 3365:            reinterpret_cast<sockaddr_in6_type*>(ai->ai_addr);
        -: 3366:          if (sin6ptr->sin6_port == 0)
        -: 3367:            sin6ptr->sin6_port = port;
        -: 3368:          break;
        -: 3369:        }
        -: 3370:      default:
        -: 3371:        break;
        -: 3372:      }
        -: 3373:    }
        -: 3374:  }
        -: 3375:#endif
        -: 3376:  return ec = translate_addrinfo_error(error);
        -: 3377:#endif
        -: 3378:}
        -: 3379:
        -: 3380:boost::system::error_code background_getaddrinfo(
        -: 3381:    const weak_cancel_token_type& cancel_token, const char* host,
        -: 3382:    const char* service, const addrinfo_type& hints,
        -: 3383:    addrinfo_type** result, boost::system::error_code& ec)
        -: 3384:{
        -: 3385:  if (cancel_token.expired())
        -: 3386:    ec = boost::asio::error::operation_aborted;
        -: 3387:  else
        -: 3388:    socket_ops::getaddrinfo(host, service, hints, result, ec);
        -: 3389:  return ec;
        -: 3390:}
        -: 3391:
        -: 3392:void freeaddrinfo(addrinfo_type* ai)
        -: 3393:{
        -: 3394:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3395:# if defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3396:  // Building for Windows XP, Windows Server 2003, or later.
        -: 3397:  ::freeaddrinfo(ai);
        -: 3398:# else
        -: 3399:  // Building for Windows 2000 or earlier.
        -: 3400:  typedef int (WSAAPI *fai_t)(addrinfo_type*);
        -: 3401:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 3402:  {
        -: 3403:    if (fai_t fai = (fai_t)::GetProcAddress(winsock_module, "freeaddrinfo"))
        -: 3404:    {
        -: 3405:      fai(ai);
        -: 3406:      return;
        -: 3407:    }
        -: 3408:  }
        -: 3409:  freeaddrinfo_emulation(ai);
        -: 3410:# endif
        -: 3411:#elif !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3412:  freeaddrinfo_emulation(ai);
        -: 3413:#else
        -: 3414:  ::freeaddrinfo(ai);
        -: 3415:#endif
        -: 3416:}
        -: 3417:
        -: 3418:boost::system::error_code getnameinfo(const socket_addr_type* addr,
        -: 3419:    std::size_t addrlen, char* host, std::size_t hostlen,
        -: 3420:    char* serv, std::size_t servlen, int flags, boost::system::error_code& ec)
        -: 3421:{
        -: 3422:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3423:# if defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3424:  // Building for Windows XP, Windows Server 2003, or later.
        -: 3425:  clear_last_error();
        -: 3426:  int error = ::getnameinfo(addr, static_cast<socklen_t>(addrlen),
        -: 3427:      host, static_cast<DWORD>(hostlen),
        -: 3428:      serv, static_cast<DWORD>(servlen), flags);
        -: 3429:  return ec = translate_addrinfo_error(error);
        -: 3430:# else
        -: 3431:  // Building for Windows 2000 or earlier.
        -: 3432:  typedef int (WSAAPI *gni_t)(const socket_addr_type*,
        -: 3433:      int, char*, DWORD, char*, DWORD, int);
        -: 3434:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 3435:  {
        -: 3436:    if (gni_t gni = (gni_t)::GetProcAddress(winsock_module, "getnameinfo"))
        -: 3437:    {
        -: 3438:      clear_last_error();
        -: 3439:      int error = gni(addr, static_cast<int>(addrlen),
        -: 3440:          host, static_cast<DWORD>(hostlen),
        -: 3441:          serv, static_cast<DWORD>(servlen), flags);
        -: 3442:      return ec = translate_addrinfo_error(error);
        -: 3443:    }
        -: 3444:  }
        -: 3445:  clear_last_error();
        -: 3446:  return getnameinfo_emulation(addr, addrlen,
        -: 3447:      host, hostlen, serv, servlen, flags, ec);
        -: 3448:# endif
        -: 3449:#elif !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3450:  using namespace std; // For memcpy.
        -: 3451:  sockaddr_storage_type tmp_addr;
        -: 3452:  memcpy(&tmp_addr, addr, addrlen);
        -: 3453:  addr = reinterpret_cast<socket_addr_type*>(&tmp_addr);
        -: 3454:  clear_last_error();
        -: 3455:  return getnameinfo_emulation(addr, addrlen,
        -: 3456:      host, hostlen, serv, servlen, flags, ec);
        -: 3457:#else
        -: 3458:  clear_last_error();
        -: 3459:  int error = ::getnameinfo(addr, addrlen, host, hostlen, serv, servlen, flags);
        -: 3460:  return ec = translate_addrinfo_error(error);
        -: 3461:#endif
        -: 3462:}
        -: 3463:
        -: 3464:boost::system::error_code sync_getnameinfo(
        -: 3465:    const socket_addr_type* addr, std::size_t addrlen,
        -: 3466:    char* host, std::size_t hostlen, char* serv,
        -: 3467:    std::size_t servlen, int sock_type, boost::system::error_code& ec)
        -: 3468:{
        -: 3469:  // First try resolving with the service name. If that fails try resolving
        -: 3470:  // but allow the service to be returned as a number.
        -: 3471:  int flags = (sock_type == SOCK_DGRAM) ? NI_DGRAM : 0;
        -: 3472:  socket_ops::getnameinfo(addr, addrlen, host,
        -: 3473:      hostlen, serv, servlen, flags, ec);
        -: 3474:  if (ec)
        -: 3475:  {
        -: 3476:    socket_ops::getnameinfo(addr, addrlen, host, hostlen,
        -: 3477:        serv, servlen, flags | NI_NUMERICSERV, ec);
        -: 3478:  }
        -: 3479:
        -: 3480:  return ec;
        -: 3481:}
        -: 3482:
        -: 3483:boost::system::error_code background_getnameinfo(
        -: 3484:    const weak_cancel_token_type& cancel_token,
        -: 3485:    const socket_addr_type* addr, std::size_t addrlen,
        -: 3486:    char* host, std::size_t hostlen, char* serv,
        -: 3487:    std::size_t servlen, int sock_type, boost::system::error_code& ec)
        -: 3488:{
        -: 3489:  if (cancel_token.expired())
        -: 3490:  {
        -: 3491:    ec = boost::asio::error::operation_aborted;
        -: 3492:  }
        -: 3493:  else
        -: 3494:  {
        -: 3495:    // First try resolving with the service name. If that fails try resolving
        -: 3496:    // but allow the service to be returned as a number.
        -: 3497:    int flags = (sock_type == SOCK_DGRAM) ? NI_DGRAM : 0;
        -: 3498:    socket_ops::getnameinfo(addr, addrlen, host,
        -: 3499:        hostlen, serv, servlen, flags, ec);
        -: 3500:    if (ec)
        -: 3501:    {
        -: 3502:      socket_ops::getnameinfo(addr, addrlen, host, hostlen,
        -: 3503:          serv, servlen, flags | NI_NUMERICSERV, ec);
        -: 3504:    }
        -: 3505:  }
        -: 3506:
        -: 3507:  return ec;
        -: 3508:}
        -: 3509:
        -: 3510:#endif // !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3511:
        -: 3512:u_long_type network_to_host_long(u_long_type value)
        -: 3513:{
        -: 3514:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3515:  unsigned char* value_p = reinterpret_cast<unsigned char*>(&value);
        -: 3516:  u_long_type result = (static_cast<u_long_type>(value_p[0]) << 24)
        -: 3517:    | (static_cast<u_long_type>(value_p[1]) << 16)
        -: 3518:    | (static_cast<u_long_type>(value_p[2]) << 8)
        -: 3519:    | static_cast<u_long_type>(value_p[3]);
        -: 3520:  return result;
        -: 3521:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3522:  return ntohl(value);
        -: 3523:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3524:}
        -: 3525:
        -: 3526:u_long_type host_to_network_long(u_long_type value)
        -: 3527:{
        -: 3528:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3529:  u_long_type result;
        -: 3530:  unsigned char* result_p = reinterpret_cast<unsigned char*>(&result);
        -: 3531:  result_p[0] = static_cast<unsigned char>((value >> 24) & 0xFF);
        -: 3532:  result_p[1] = static_cast<unsigned char>((value >> 16) & 0xFF);
        -: 3533:  result_p[2] = static_cast<unsigned char>((value >> 8) & 0xFF);
        -: 3534:  result_p[3] = static_cast<unsigned char>(value & 0xFF);
        -: 3535:  return result;
        -: 3536:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3537:  return htonl(value);
        -: 3538:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3539:}
        -: 3540:
        -: 3541:u_short_type network_to_host_short(u_short_type value)
        -: 3542:{
        -: 3543:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3544:  unsigned char* value_p = reinterpret_cast<unsigned char*>(&value);
        -: 3545:  u_short_type result = (static_cast<u_short_type>(value_p[0]) << 8)
        -: 3546:    | static_cast<u_short_type>(value_p[1]);
        -: 3547:  return result;
        -: 3548:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3549:  return ntohs(value);
        -: 3550:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3551:}
        -: 3552:
        -: 3553:u_short_type host_to_network_short(u_short_type value)
        -: 3554:{
        -: 3555:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3556:  u_short_type result;
        -: 3557:  unsigned char* result_p = reinterpret_cast<unsigned char*>(&result);
        -: 3558:  result_p[0] = static_cast<unsigned char>((value >> 8) & 0xFF);
        -: 3559:  result_p[1] = static_cast<unsigned char>(value & 0xFF);
        -: 3560:  return result;
        -: 3561:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3562:  return htons(value);
        -: 3563:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3564:}
        -: 3565:
        -: 3566:} // namespace socket_ops
        -: 3567:} // namespace detail
        -: 3568:} // namespace asio
        -: 3569:} // namespace boost
        -: 3570:
        -: 3571:#include <boost/asio/detail/pop_options.hpp>
        -: 3572:
        -: 3573:#endif // BOOST_ASIO_DETAIL_SOCKET_OPS_IPP
