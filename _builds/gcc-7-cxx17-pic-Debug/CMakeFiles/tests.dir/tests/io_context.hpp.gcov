        -:    0:Source:/root/.hunter/_Base/70287b1/fc9dcb2/dffbc08/Install/include/boost/asio/impl/io_context.hpp
        -:    0:Graph:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/tests.dir/tests/test.cpp.gcno
        -:    0:Data:/home/vagrant/labs/lab-08-asio-client/_builds/gcc-7-cxx17-pic-Debug/CMakeFiles/tests.dir/tests/test.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// impl/io_context.hpp
        -:    3:// ~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_IMPL_IO_CONTEXT_HPP
        -:   12:#define BOOST_ASIO_IMPL_IO_CONTEXT_HPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/completion_handler.hpp>
        -:   19:#include <boost/asio/detail/executor_op.hpp>
        -:   20:#include <boost/asio/detail/fenced_block.hpp>
        -:   21:#include <boost/asio/detail/handler_type_requirements.hpp>
        -:   22:#include <boost/asio/detail/recycling_allocator.hpp>
        -:   23:#include <boost/asio/detail/service_registry.hpp>
        -:   24:#include <boost/asio/detail/throw_error.hpp>
        -:   25:#include <boost/asio/detail/type_traits.hpp>
        -:   26:
        -:   27:#include <boost/asio/detail/push_options.hpp>
        -:   28:
        -:   29:namespace boost {
        -:   30:namespace asio {
        -:   31:
        -:   32:template <typename Service>
        2:   33:inline Service& use_service(io_context& ioc)
        -:   34:{
        -:   35:  // Check that Service meets the necessary type requirements.
        -:   36:  (void)static_cast<execution_context::service*>(static_cast<Service*>(0));
        -:   37:  (void)static_cast<const execution_context::id*>(&Service::id);
        -:   38:
        2:   39:  return ioc.service_registry_->template use_service<Service>(ioc);
        -:   40:}
        -:   41:
        -:   42:template <>
        -:   43:inline detail::io_context_impl& use_service<detail::io_context_impl>(
        -:   44:    io_context& ioc)
        -:   45:{
        -:   46:  return ioc.impl_;
        -:   47:}
        -:   48:
        -:   49:} // namespace asio
        -:   50:} // namespace boost
        -:   51:
        -:   52:#include <boost/asio/detail/pop_options.hpp>
        -:   53:
        -:   54:#if defined(BOOST_ASIO_HAS_IOCP)
        -:   55:# include <boost/asio/detail/win_iocp_io_context.hpp>
        -:   56:#else
        -:   57:# include <boost/asio/detail/scheduler.hpp>
        -:   58:#endif
        -:   59:
        -:   60:#include <boost/asio/detail/push_options.hpp>
        -:   61:
        -:   62:namespace boost {
        -:   63:namespace asio {
        -:   64:
        -:   65:inline io_context::executor_type
        -:   66:io_context::get_executor() BOOST_ASIO_NOEXCEPT
        -:   67:{
        -:   68:  return executor_type(*this);
        -:   69:}
        -:   70:
        -:   71:#if defined(BOOST_ASIO_HAS_CHRONO)
        -:   72:
        -:   73:template <typename Rep, typename Period>
        -:   74:std::size_t io_context::run_for(
        -:   75:    const chrono::duration<Rep, Period>& rel_time)
        -:   76:{
        -:   77:  return this->run_until(chrono::steady_clock::now() + rel_time);
        -:   78:}
        -:   79:
        -:   80:template <typename Clock, typename Duration>
        -:   81:std::size_t io_context::run_until(
        -:   82:    const chrono::time_point<Clock, Duration>& abs_time)
        -:   83:{
        -:   84:  std::size_t n = 0;
        -:   85:  while (this->run_one_until(abs_time))
        -:   86:    if (n != (std::numeric_limits<std::size_t>::max)())
        -:   87:      ++n;
        -:   88:  return n;
        -:   89:}
        -:   90:
        -:   91:template <typename Rep, typename Period>
        -:   92:std::size_t io_context::run_one_for(
        -:   93:    const chrono::duration<Rep, Period>& rel_time)
        -:   94:{
        -:   95:  return this->run_one_until(chrono::steady_clock::now() + rel_time);
        -:   96:}
        -:   97:
        -:   98:template <typename Clock, typename Duration>
        -:   99:std::size_t io_context::run_one_until(
        -:  100:    const chrono::time_point<Clock, Duration>& abs_time)
        -:  101:{
        -:  102:  typename Clock::time_point now = Clock::now();
        -:  103:  while (now < abs_time)
        -:  104:  {
        -:  105:    typename Clock::duration rel_time = abs_time - now;
        -:  106:    if (rel_time > chrono::seconds(1))
        -:  107:      rel_time = chrono::seconds(1);
        -:  108:
        -:  109:    boost::system::error_code ec;
        -:  110:    std::size_t s = impl_.wait_one(
        -:  111:        static_cast<long>(chrono::duration_cast<
        -:  112:          chrono::microseconds>(rel_time).count()), ec);
        -:  113:    boost::asio::detail::throw_error(ec);
        -:  114:
        -:  115:    if (s || impl_.stopped())
        -:  116:      return s;
        -:  117:
        -:  118:    now = Clock::now();
        -:  119:  }
        -:  120:
        -:  121:  return 0;
        -:  122:}
        -:  123:
        -:  124:#endif // defined(BOOST_ASIO_HAS_CHRONO)
        -:  125:
        -:  126:#if !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  127:
        -:  128:inline void io_context::reset()
        -:  129:{
        -:  130:  restart();
        -:  131:}
        -:  132:
        -:  133:template <typename LegacyCompletionHandler>
        -:  134:BOOST_ASIO_INITFN_RESULT_TYPE(LegacyCompletionHandler, void ())
        -:  135:io_context::dispatch(BOOST_ASIO_MOVE_ARG(LegacyCompletionHandler) handler)
        -:  136:{
        -:  137:  // If you get an error on the following line it means that your handler does
        -:  138:  // not meet the documented type requirements for a LegacyCompletionHandler.
        -:  139:  BOOST_ASIO_LEGACY_COMPLETION_HANDLER_CHECK(
        -:  140:      LegacyCompletionHandler, handler) type_check;
        -:  141:
        -:  142:  async_completion<LegacyCompletionHandler, void ()> init(handler);
        -:  143:
        -:  144:  if (impl_.can_dispatch())
        -:  145:  {
        -:  146:    detail::fenced_block b(detail::fenced_block::full);
        -:  147:    boost_asio_handler_invoke_helpers::invoke(
        -:  148:        init.completion_handler, init.completion_handler);
        -:  149:  }
        -:  150:  else
        -:  151:  {
        -:  152:    // Allocate and construct an operation to wrap the handler.
        -:  153:    typedef detail::completion_handler<
        -:  154:      typename handler_type<LegacyCompletionHandler, void ()>::type> op;
        -:  155:    typename op::ptr p = { detail::addressof(init.completion_handler),
        -:  156:      op::ptr::allocate(init.completion_handler), 0 };
        -:  157:    p.p = new (p.v) op(init.completion_handler);
        -:  158:
        -:  159:    BOOST_ASIO_HANDLER_CREATION((*this, *p.p,
        -:  160:          "io_context", this, 0, "dispatch"));
        -:  161:
        -:  162:    impl_.do_dispatch(p.p);
        -:  163:    p.v = p.p = 0;
        -:  164:  }
        -:  165:
        -:  166:  return init.result.get();
        -:  167:}
        -:  168:
        -:  169:template <typename LegacyCompletionHandler>
        -:  170:BOOST_ASIO_INITFN_RESULT_TYPE(LegacyCompletionHandler, void ())
        -:  171:io_context::post(BOOST_ASIO_MOVE_ARG(LegacyCompletionHandler) handler)
        -:  172:{
        -:  173:  // If you get an error on the following line it means that your handler does
        -:  174:  // not meet the documented type requirements for a LegacyCompletionHandler.
        -:  175:  BOOST_ASIO_LEGACY_COMPLETION_HANDLER_CHECK(
        -:  176:      LegacyCompletionHandler, handler) type_check;
        -:  177:
        -:  178:  async_completion<LegacyCompletionHandler, void ()> init(handler);
        -:  179:
        -:  180:  bool is_continuation =
        -:  181:    boost_asio_handler_cont_helpers::is_continuation(init.completion_handler);
        -:  182:
        -:  183:  // Allocate and construct an operation to wrap the handler.
        -:  184:  typedef detail::completion_handler<
        -:  185:    typename handler_type<LegacyCompletionHandler, void ()>::type> op;
        -:  186:  typename op::ptr p = { detail::addressof(init.completion_handler),
        -:  187:      op::ptr::allocate(init.completion_handler), 0 };
        -:  188:  p.p = new (p.v) op(init.completion_handler);
        -:  189:
        -:  190:  BOOST_ASIO_HANDLER_CREATION((*this, *p.p,
        -:  191:        "io_context", this, 0, "post"));
        -:  192:
        -:  193:  impl_.post_immediate_completion(p.p, is_continuation);
        -:  194:  p.v = p.p = 0;
        -:  195:
        -:  196:  return init.result.get();
        -:  197:}
        -:  198:
        -:  199:template <typename Handler>
        -:  200:#if defined(GENERATING_DOCUMENTATION)
        -:  201:unspecified
        -:  202:#else
        -:  203:inline detail::wrapped_handler<io_context&, Handler>
        -:  204:#endif
        -:  205:io_context::wrap(Handler handler)
        -:  206:{
        -:  207:  return detail::wrapped_handler<io_context&, Handler>(*this, handler);
        -:  208:}
        -:  209:
        -:  210:#endif // !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  211:
        -:  212:inline io_context&
        -:  213:io_context::executor_type::context() const BOOST_ASIO_NOEXCEPT
        -:  214:{
        -:  215:  return io_context_;
        -:  216:}
        -:  217:
        -:  218:inline void
        -:  219:io_context::executor_type::on_work_started() const BOOST_ASIO_NOEXCEPT
        -:  220:{
        -:  221:  io_context_.impl_.work_started();
        -:  222:}
        -:  223:
        -:  224:inline void
        -:  225:io_context::executor_type::on_work_finished() const BOOST_ASIO_NOEXCEPT
        -:  226:{
        -:  227:  io_context_.impl_.work_finished();
        -:  228:}
        -:  229:
        -:  230:template <typename Function, typename Allocator>
        -:  231:void io_context::executor_type::dispatch(
        -:  232:    BOOST_ASIO_MOVE_ARG(Function) f, const Allocator& a) const
        -:  233:{
        -:  234:  typedef typename decay<Function>::type function_type;
        -:  235:
        -:  236:  // Invoke immediately if we are already inside the thread pool.
        -:  237:  if (io_context_.impl_.can_dispatch())
        -:  238:  {
        -:  239:    // Make a local, non-const copy of the function.
        -:  240:    function_type tmp(BOOST_ASIO_MOVE_CAST(Function)(f));
        -:  241:
        -:  242:    detail::fenced_block b(detail::fenced_block::full);
        -:  243:    boost_asio_handler_invoke_helpers::invoke(tmp, tmp);
        -:  244:    return;
        -:  245:  }
        -:  246:
        -:  247:  // Allocate and construct an operation to wrap the function.
        -:  248:  typedef detail::executor_op<function_type, Allocator, detail::operation> op;
        -:  249:  typename op::ptr p = { detail::addressof(a), op::ptr::allocate(a), 0 };
        -:  250:  p.p = new (p.v) op(BOOST_ASIO_MOVE_CAST(Function)(f), a);
        -:  251:
        -:  252:  BOOST_ASIO_HANDLER_CREATION((this->context(), *p.p,
        -:  253:        "io_context", &this->context(), 0, "post"));
        -:  254:
        -:  255:  io_context_.impl_.post_immediate_completion(p.p, false);
        -:  256:  p.v = p.p = 0;
        -:  257:}
        -:  258:
        -:  259:template <typename Function, typename Allocator>
        -:  260:void io_context::executor_type::post(
        -:  261:    BOOST_ASIO_MOVE_ARG(Function) f, const Allocator& a) const
        -:  262:{
        -:  263:  typedef typename decay<Function>::type function_type;
        -:  264:
        -:  265:  // Allocate and construct an operation to wrap the function.
        -:  266:  typedef detail::executor_op<function_type, Allocator, detail::operation> op;
        -:  267:  typename op::ptr p = { detail::addressof(a), op::ptr::allocate(a), 0 };
        -:  268:  p.p = new (p.v) op(BOOST_ASIO_MOVE_CAST(Function)(f), a);
        -:  269:
        -:  270:  BOOST_ASIO_HANDLER_CREATION((this->context(), *p.p,
        -:  271:        "io_context", &this->context(), 0, "post"));
        -:  272:
        -:  273:  io_context_.impl_.post_immediate_completion(p.p, false);
        -:  274:  p.v = p.p = 0;
        -:  275:}
        -:  276:
        -:  277:template <typename Function, typename Allocator>
        -:  278:void io_context::executor_type::defer(
        -:  279:    BOOST_ASIO_MOVE_ARG(Function) f, const Allocator& a) const
        -:  280:{
        -:  281:  typedef typename decay<Function>::type function_type;
        -:  282:
        -:  283:  // Allocate and construct an operation to wrap the function.
        -:  284:  typedef detail::executor_op<function_type, Allocator, detail::operation> op;
        -:  285:  typename op::ptr p = { detail::addressof(a), op::ptr::allocate(a), 0 };
        -:  286:  p.p = new (p.v) op(BOOST_ASIO_MOVE_CAST(Function)(f), a);
        -:  287:
        -:  288:  BOOST_ASIO_HANDLER_CREATION((this->context(), *p.p,
        -:  289:        "io_context", &this->context(), 0, "defer"));
        -:  290:
        -:  291:  io_context_.impl_.post_immediate_completion(p.p, true);
        -:  292:  p.v = p.p = 0;
        -:  293:}
        -:  294:
        -:  295:inline bool
        -:  296:io_context::executor_type::running_in_this_thread() const BOOST_ASIO_NOEXCEPT
        -:  297:{
        -:  298:  return io_context_.impl_.can_dispatch();
        -:  299:}
        -:  300:
        -:  301:#if !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  302:inline io_context::work::work(boost::asio::io_context& io_context)
        -:  303:  : io_context_impl_(io_context.impl_)
        -:  304:{
        -:  305:  io_context_impl_.work_started();
        -:  306:}
        -:  307:
        -:  308:inline io_context::work::work(const work& other)
        -:  309:  : io_context_impl_(other.io_context_impl_)
        -:  310:{
        -:  311:  io_context_impl_.work_started();
        -:  312:}
        -:  313:
        -:  314:inline io_context::work::~work()
        -:  315:{
        -:  316:  io_context_impl_.work_finished();
        -:  317:}
        -:  318:
        -:  319:inline boost::asio::io_context& io_context::work::get_io_context()
        -:  320:{
        -:  321:  return static_cast<boost::asio::io_context&>(io_context_impl_.context());
        -:  322:}
        -:  323:
        -:  324:inline boost::asio::io_context& io_context::work::get_io_service()
        -:  325:{
        -:  326:  return static_cast<boost::asio::io_context&>(io_context_impl_.context());
        -:  327:}
        -:  328:#endif // !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  329:
        -:  330:inline boost::asio::io_context& io_context::service::get_io_context()
        -:  331:{
        -:  332:  return static_cast<boost::asio::io_context&>(context());
        -:  333:}
        -:  334:
        -:  335:#if !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  336:inline boost::asio::io_context& io_context::service::get_io_service()
        -:  337:{
        -:  338:  return static_cast<boost::asio::io_context&>(context());
        -:  339:}
        -:  340:#endif // !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  341:
        -:  342:} // namespace asio
        -:  343:} // namespace boost
        -:  344:
        -:  345:#include <boost/asio/detail/pop_options.hpp>
        -:  346:
        -:  347:#endif // BOOST_ASIO_IMPL_IO_CONTEXT_HPP
